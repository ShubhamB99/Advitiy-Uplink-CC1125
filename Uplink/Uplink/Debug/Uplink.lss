
Uplink.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000008c0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000002e  00802000  000008c0  00000954  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000016d  0080202e  0080202e  00000982  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000982  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000009b4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000130  00000000  00000000  000009f4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000055a8  00000000  00000000  00000b24  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000035c4  00000000  00000000  000060cc  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000012c7  00000000  00000000  00009690  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000338  00000000  00000000  0000a958  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00002ff7  00000000  00000000  0000ac90  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001a5d  00000000  00000000  0000dc87  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000150  00000000  00000000  0000f6e4  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__ctors_end>
   4:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
   8:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
   c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  10:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  14:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  18:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  1c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  20:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  24:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  28:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  2c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  30:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  34:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  38:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  3c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  40:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  44:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  48:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  4c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  50:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  54:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  58:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  5c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  60:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  64:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  68:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  6c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  70:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  74:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  78:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  7c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  80:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  84:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  88:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  8c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  90:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  94:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  98:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  9c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  a0:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  a4:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  a8:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  ac:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  b0:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  b4:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  b8:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  bc:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  c0:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  c4:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  c8:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  cc:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  d0:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  d4:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  d8:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  dc:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  e0:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  e4:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  e8:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  ec:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  f0:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  f4:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  f8:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  fc:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 100:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 104:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 108:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 10c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 110:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 114:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 118:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 11c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 120:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 124:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 128:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 12c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 130:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 134:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 138:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 13c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 140:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 144:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 148:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 14c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 150:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 154:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 158:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 15c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 160:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 164:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 168:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 16c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 170:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 174:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 178:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 17c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 180:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 184:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 188:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 18c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 190:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 194:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 198:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 19c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1a0:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1a4:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1a8:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1ac:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1b0:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1b4:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1b8:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1bc:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1c0:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1c4:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1c8:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1cc:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1d0:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1d4:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1d8:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1dc:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1e0:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1e4:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1e8:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1ec:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1f0:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1f4:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1f8:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>

000001fc <__ctors_end>:
 1fc:	11 24       	eor	r1, r1
 1fe:	1f be       	out	0x3f, r1	; 63
 200:	cf ef       	ldi	r28, 0xFF	; 255
 202:	cd bf       	out	0x3d, r28	; 61
 204:	df e3       	ldi	r29, 0x3F	; 63
 206:	de bf       	out	0x3e, r29	; 62
 208:	00 e0       	ldi	r16, 0x00	; 0
 20a:	0c bf       	out	0x3c, r16	; 60

0000020c <__do_copy_data>:
 20c:	10 e2       	ldi	r17, 0x20	; 32
 20e:	a0 e0       	ldi	r26, 0x00	; 0
 210:	b0 e2       	ldi	r27, 0x20	; 32
 212:	e0 ec       	ldi	r30, 0xC0	; 192
 214:	f8 e0       	ldi	r31, 0x08	; 8
 216:	00 e0       	ldi	r16, 0x00	; 0
 218:	0b bf       	out	0x3b, r16	; 59
 21a:	02 c0       	rjmp	.+4      	; 0x220 <__do_copy_data+0x14>
 21c:	07 90       	elpm	r0, Z+
 21e:	0d 92       	st	X+, r0
 220:	ae 32       	cpi	r26, 0x2E	; 46
 222:	b1 07       	cpc	r27, r17
 224:	d9 f7       	brne	.-10     	; 0x21c <__do_copy_data+0x10>

00000226 <__do_clear_bss>:
 226:	21 e2       	ldi	r18, 0x21	; 33
 228:	ae e2       	ldi	r26, 0x2E	; 46
 22a:	b0 e2       	ldi	r27, 0x20	; 32
 22c:	01 c0       	rjmp	.+2      	; 0x230 <.do_clear_bss_start>

0000022e <.do_clear_bss_loop>:
 22e:	1d 92       	st	X+, r1

00000230 <.do_clear_bss_start>:
 230:	ab 39       	cpi	r26, 0x9B	; 155
 232:	b2 07       	cpc	r27, r18
 234:	e1 f7       	brne	.-8      	; 0x22e <.do_clear_bss_loop>
 236:	0e 94 34 04 	call	0x868	; 0x868 <main>
 23a:	0c 94 5e 04 	jmp	0x8bc	; 0x8bc <_exit>

0000023e <__bad_interrupt>:
 23e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000242 <crc16>:
	spi->dataPacket->bytesTransceived = bytesTransceived;
	spi->dataPacket->complete = true;

	/* Report success. */
	return true;
}
 242:	7f ef       	ldi	r23, 0xFF	; 255
 244:	76 0f       	add	r23, r22
 246:	66 23       	and	r22, r22
 248:	29 f1       	breq	.+74     	; 0x294 <crc16+0x52>
 24a:	e8 2f       	mov	r30, r24
 24c:	f9 2f       	mov	r31, r25
 24e:	4f ef       	ldi	r20, 0xFF	; 255
 250:	5f ef       	ldi	r21, 0xFF	; 255
 252:	21 91       	ld	r18, Z+
 254:	25 27       	eor	r18, r21
 256:	32 2f       	mov	r19, r18
 258:	32 95       	swap	r19
 25a:	3f 70       	andi	r19, 0x0F	; 15
 25c:	92 2f       	mov	r25, r18
 25e:	93 27       	eor	r25, r19
 260:	29 2f       	mov	r18, r25
 262:	30 e0       	ldi	r19, 0x00	; 0
 264:	54 2f       	mov	r21, r20
 266:	44 27       	eor	r20, r20
 268:	42 27       	eor	r20, r18
 26a:	53 27       	eor	r21, r19
 26c:	c9 01       	movw	r24, r18
 26e:	98 2f       	mov	r25, r24
 270:	88 27       	eor	r24, r24
 272:	92 95       	swap	r25
 274:	90 7f       	andi	r25, 0xF0	; 240
 276:	48 27       	eor	r20, r24
 278:	59 27       	eor	r21, r25
 27a:	22 0f       	add	r18, r18
 27c:	33 1f       	adc	r19, r19
 27e:	22 95       	swap	r18
 280:	32 95       	swap	r19
 282:	30 7f       	andi	r19, 0xF0	; 240
 284:	32 27       	eor	r19, r18
 286:	20 7f       	andi	r18, 0xF0	; 240
 288:	32 27       	eor	r19, r18
 28a:	42 27       	eor	r20, r18
 28c:	53 27       	eor	r21, r19
 28e:	71 50       	subi	r23, 0x01	; 1
 290:	00 f7       	brcc	.-64     	; 0x252 <crc16+0x10>
 292:	02 c0       	rjmp	.+4      	; 0x298 <crc16+0x56>
 294:	4f ef       	ldi	r20, 0xFF	; 255
 296:	5f ef       	ldi	r21, 0xFF	; 255
 298:	ca 01       	movw	r24, r20
 29a:	08 95       	ret

0000029c <USART_TXBuffer_FreeSpace>:
 29c:	fc 01       	movw	r30, r24
 29e:	95 85       	ldd	r25, Z+13	; 0x0d
 2a0:	26 85       	ldd	r18, Z+14	; 0x0e
 2a2:	9f 5f       	subi	r25, 0xFF	; 255
 2a4:	93 70       	andi	r25, 0x03	; 3
 2a6:	81 e0       	ldi	r24, 0x01	; 1
 2a8:	92 13       	cpse	r25, r18
 2aa:	01 c0       	rjmp	.+2      	; 0x2ae <USART_TXBuffer_FreeSpace+0x12>
 2ac:	80 e0       	ldi	r24, 0x00	; 0
 2ae:	08 95       	ret

000002b0 <USART_TXBuffer_PutByte>:
 2b0:	1f 93       	push	r17
 2b2:	cf 93       	push	r28
 2b4:	df 93       	push	r29
 2b6:	ec 01       	movw	r28, r24
 2b8:	16 2f       	mov	r17, r22
 2ba:	0e 94 4e 01 	call	0x29c	; 0x29c <USART_TXBuffer_FreeSpace>
 2be:	88 23       	and	r24, r24
 2c0:	79 f0       	breq	.+30     	; 0x2e0 <USART_TXBuffer_PutByte+0x30>
 2c2:	9d 85       	ldd	r25, Y+13	; 0x0d
 2c4:	fe 01       	movw	r30, r28
 2c6:	e9 0f       	add	r30, r25
 2c8:	f1 1d       	adc	r31, r1
 2ca:	17 83       	std	Z+7, r17	; 0x07
 2cc:	9f 5f       	subi	r25, 0xFF	; 255
 2ce:	93 70       	andi	r25, 0x03	; 3
 2d0:	9d 87       	std	Y+13, r25	; 0x0d
 2d2:	e8 81       	ld	r30, Y
 2d4:	f9 81       	ldd	r31, Y+1	; 0x01
 2d6:	93 81       	ldd	r25, Z+3	; 0x03
 2d8:	9c 7f       	andi	r25, 0xFC	; 252
 2da:	2a 81       	ldd	r18, Y+2	; 0x02
 2dc:	92 2b       	or	r25, r18
 2de:	93 83       	std	Z+3, r25	; 0x03
 2e0:	df 91       	pop	r29
 2e2:	cf 91       	pop	r28
 2e4:	1f 91       	pop	r17
 2e6:	08 95       	ret

000002e8 <SPI_Master_Init>:

}
*/

void SPI_Master_Init()	
{
 2e8:	cf 93       	push	r28
 2ea:	df 93       	push	r29
	// ** Do initialisation to 2 ports for UART **
	
	//SPI Register Configuration
	PORTE.DIRSET = PIN4_bm;																							//Set SS as output
 2ec:	e0 e8       	ldi	r30, 0x80	; 128
 2ee:	f6 e0       	ldi	r31, 0x06	; 6
 2f0:	20 e1       	ldi	r18, 0x10	; 16
 2f2:	21 83       	std	Z+1, r18	; 0x01
	PORTE.DIRSET = PIN5_bm;																							//MOSI as output
 2f4:	80 e2       	ldi	r24, 0x20	; 32
 2f6:	81 83       	std	Z+1, r24	; 0x01
	PORTE.DIRSET = PIN7_bm;																							//SCK as output
 2f8:	90 e8       	ldi	r25, 0x80	; 128
 2fa:	91 83       	std	Z+1, r25	; 0x01
	PORTE.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;																		//Set PullUp at SS 
 2fc:	38 e3       	ldi	r19, 0x38	; 56
 2fe:	34 8b       	std	Z+20, r19	; 0x14
	// We can't leave PIN4 to a floating state of 0 or 3.3V when in idle state, so we set it to always high being connected to VCC until we explicitly make it low
	PORTE.OUTSET = PIN4_bm;																							//Set SS high for no Slave
 300:	25 83       	std	Z+5, r18	; 0x05
                    SPI_MODE_t mode,
                    SPI_INTLVL_t intLevel,
                    bool clk2x,
                    SPI_PRESCALER_t clockDivision)
{
	spi->module         = module;
 302:	a8 ef       	ldi	r26, 0xF8	; 248
 304:	b0 e2       	ldi	r27, 0x20	; 32
 306:	c0 ec       	ldi	r28, 0xC0	; 192
 308:	d8 e0       	ldi	r29, 0x08	; 8
 30a:	cd 93       	st	X+, r28
 30c:	dc 93       	st	X, r29
 30e:	11 97       	sbiw	r26, 0x01	; 1
	spi->port           = port;
 310:	12 96       	adiw	r26, 0x02	; 2
 312:	ed 93       	st	X+, r30
 314:	fc 93       	st	X, r31
 316:	13 97       	sbiw	r26, 0x03	; 3
	spi->interrupted    = false;
 318:	14 96       	adiw	r26, 0x04	; 4
 31a:	1c 92       	st	X, r1
 31c:	14 97       	sbiw	r26, 0x04	; 4

	spi->module->CTRL   = clockDivision |                  /* SPI prescaler. */
 31e:	28 ed       	ldi	r18, 0xD8	; 216
 320:	28 83       	st	Y, r18
	                      (lsbFirst ? SPI_DORD_bm  : 0) |  /* Data order. */
	                      SPI_MASTER_bm |                  /* SPI master. */
	                      mode;                            /* SPI mode. */

	/* Interrupt level. */
	spi->module->INTCTRL = intLevel;
 322:	cd 91       	ld	r28, X+
 324:	dc 91       	ld	r29, X
 326:	11 97       	sbiw	r26, 0x01	; 1
 328:	19 82       	std	Y+1, r1	; 0x01

	/* No assigned data packet. */
	spi->dataPacket = NULL;
 32a:	15 96       	adiw	r26, 0x05	; 5
 32c:	1d 92       	st	X+, r1
 32e:	1c 92       	st	X, r1
 330:	16 97       	sbiw	r26, 0x06	; 6

 	/* MOSI and SCK as output. */
	spi->port->DIRSET  = SPI_MOSI_bm | SPI_SCK_bm;
 332:	12 96       	adiw	r26, 0x02	; 2
 334:	0d 90       	ld	r0, X+
 336:	bc 91       	ld	r27, X
 338:	a0 2d       	mov	r26, r0
 33a:	20 ea       	ldi	r18, 0xA0	; 160
 33c:	11 96       	adiw	r26, 0x01	; 1
 33e:	2c 93       	st	X, r18
	SPI_MasterInit(&spiMasterC,&SPIC,&PORTE,false,SPI_MODE_2_gc,SPI_INTLVL_OFF_gc,true,SPI_PRESCALER_DIV4_gc);		//Initialize device as master (Mode 2, MSB first, 2X speed, prescaler 4)
	// Use Mode 0, Mode 2 refers '10' in binary, false value for first 4, true for next 4, use eg. DIV16 for fosc/16 
	PORTE.OUTSET = PIN7_bm;
 340:	95 83       	std	Z+5, r25	; 0x05
	PORTE.OUTCLR = PIN5_bm;
 342:	86 83       	std	Z+6, r24	; 0x06
}
 344:	df 91       	pop	r29
 346:	cf 91       	pop	r28
 348:	08 95       	ret

0000034a <ccxxx0_Read>:


unsigned char ccxxx0_Read(unsigned char addr)			// - DONE
{
	unsigned char x; // The variable where the read Byte is stored
	PORTE.OUTCLR = PIN4_bm; // make the SS pin low to start the communication
 34a:	90 e1       	ldi	r25, 0x10	; 16
 34c:	90 93 86 06 	sts	0x0686, r25	; 0x800686 <__TEXT_REGION_LENGTH__+0x700686>

	while(PORTE.IN & PIN6_bm);
 350:	e0 e8       	ldi	r30, 0x80	; 128
 352:	f6 e0       	ldi	r31, 0x06	; 6
 354:	90 85       	ldd	r25, Z+8	; 0x08
 356:	96 fd       	sbrc	r25, 6
 358:	fd cf       	rjmp	.-6      	; 0x354 <ccxxx0_Read+0xa>

	SPIC_DATA = (addr | 0x80); // Header byte R/~W bit - 1 Burst bit - 0
 35a:	80 68       	ori	r24, 0x80	; 128
 35c:	80 93 c3 08 	sts	0x08C3, r24	; 0x8008c3 <__TEXT_REGION_LENGTH__+0x7008c3>
	while(!(SPIC_STATUS & PIN7_bm)); // Wait for transmission to be completed
 360:	e2 ec       	ldi	r30, 0xC2	; 194
 362:	f8 e0       	ldi	r31, 0x08	; 8
 364:	80 81       	ld	r24, Z
 366:	88 23       	and	r24, r24
 368:	ec f7       	brge	.-6      	; 0x364 <ccxxx0_Read+0x1a>
	x = SPIC_DATA; // flush SPDR
 36a:	e3 ec       	ldi	r30, 0xC3	; 195
 36c:	f8 e0       	ldi	r31, 0x08	; 8
 36e:	80 81       	ld	r24, Z

// Receiving the byte at addr
	SPIC_DATA = 0;
 370:	10 82       	st	Z, r1
	while(!(SPIC_STATUS & PIN7_bm));
 372:	e2 ec       	ldi	r30, 0xC2	; 194
 374:	f8 e0       	ldi	r31, 0x08	; 8
 376:	80 81       	ld	r24, Z
 378:	88 23       	and	r24, r24
 37a:	ec f7       	brge	.-6      	; 0x376 <ccxxx0_Read+0x2c>
	x = SPIC_DATA; //// flush SPDR
 37c:	80 91 c3 08 	lds	r24, 0x08C3	; 0x8008c3 <__TEXT_REGION_LENGTH__+0x7008c3>

	PORTE.OUTSET = PIN4_bm; // Make SS high to stop communication
 380:	90 e1       	ldi	r25, 0x10	; 16
 382:	90 93 85 06 	sts	0x0685, r25	; 0x800685 <__TEXT_REGION_LENGTH__+0x700685>

	return x;
}
 386:	08 95       	ret

00000388 <ccxxx0_Write>:

unsigned char ccxxx0_Write(unsigned char addr, unsigned char dat)			// - DONE
{
	unsigned char x;
	PORTE.OUTCLR = PIN4_bm;	 // make the SS pin low to start the communication
 388:	90 e1       	ldi	r25, 0x10	; 16
 38a:	90 93 86 06 	sts	0x0686, r25	; 0x800686 <__TEXT_REGION_LENGTH__+0x700686>

	while(PORTE.IN & PIN6_bm);
 38e:	e0 e8       	ldi	r30, 0x80	; 128
 390:	f6 e0       	ldi	r31, 0x06	; 6
 392:	90 85       	ldd	r25, Z+8	; 0x08
 394:	96 fd       	sbrc	r25, 6
 396:	fd cf       	rjmp	.-6      	; 0x392 <ccxxx0_Write+0xa>

	SPIC_DATA = addr; // Header Byte R/~W bit - 0 Burst bit - 0
 398:	80 93 c3 08 	sts	0x08C3, r24	; 0x8008c3 <__TEXT_REGION_LENGTH__+0x7008c3>
	while(!(SPIC_STATUS & PIN7_bm));
 39c:	e2 ec       	ldi	r30, 0xC2	; 194
 39e:	f8 e0       	ldi	r31, 0x08	; 8
 3a0:	80 81       	ld	r24, Z
 3a2:	88 23       	and	r24, r24
 3a4:	ec f7       	brge	.-6      	; 0x3a0 <ccxxx0_Write+0x18>
	x = SPIC_DATA;// flush SPDR
 3a6:	e3 ec       	ldi	r30, 0xC3	; 195
 3a8:	f8 e0       	ldi	r31, 0x08	; 8
 3aa:	80 81       	ld	r24, Z

	SPIC_DATA = dat; // data to be written at addr
 3ac:	60 83       	st	Z, r22
	while(!(SPIC_STATUS & PIN7_bm));
 3ae:	e2 ec       	ldi	r30, 0xC2	; 194
 3b0:	f8 e0       	ldi	r31, 0x08	; 8
 3b2:	80 81       	ld	r24, Z
 3b4:	88 23       	and	r24, r24
 3b6:	ec f7       	brge	.-6      	; 0x3b2 <ccxxx0_Write+0x2a>
	x = SPIC_DATA; // get data from SPDR
 3b8:	80 91 c3 08 	lds	r24, 0x08C3	; 0x8008c3 <__TEXT_REGION_LENGTH__+0x7008c3>

	PORTE.OUTSET = PIN4_bm; // Make SS high to stop communication
 3bc:	90 e1       	ldi	r25, 0x10	; 16
 3be:	90 93 85 06 	sts	0x0685, r25	; 0x800685 <__TEXT_REGION_LENGTH__+0x700685>

	return x; // The Chip Status Byte
}
 3c2:	08 95       	ret

000003c4 <ccxxx0_Strobe>:

unsigned char ccxxx0_Strobe(unsigned char addr)		// - DONE
{
    unsigned char x;
	PORTE.OUTCLR = PIN4_bm;			// make the SS pin low to start the communication
 3c4:	90 e1       	ldi	r25, 0x10	; 16
 3c6:	90 93 86 06 	sts	0x0686, r25	; 0x800686 <__TEXT_REGION_LENGTH__+0x700686>

	while(PORTE.IN & PIN6_bm);
 3ca:	e0 e8       	ldi	r30, 0x80	; 128
 3cc:	f6 e0       	ldi	r31, 0x06	; 6
 3ce:	90 85       	ldd	r25, Z+8	; 0x08
 3d0:	96 fd       	sbrc	r25, 6
 3d2:	fd cf       	rjmp	.-6      	; 0x3ce <ccxxx0_Strobe+0xa>

    SPIC_DATA = addr;				// The address of the Strobe Command
 3d4:	80 93 c3 08 	sts	0x08C3, r24	; 0x8008c3 <__TEXT_REGION_LENGTH__+0x7008c3>
	while(!(SPIC_STATUS & PIN7_bm));
 3d8:	e2 ec       	ldi	r30, 0xC2	; 194
 3da:	f8 e0       	ldi	r31, 0x08	; 8
 3dc:	80 81       	ld	r24, Z
 3de:	88 23       	and	r24, r24
 3e0:	ec f7       	brge	.-6      	; 0x3dc <ccxxx0_Strobe+0x18>
    x = SPIC_DATA;					// flush SPDR the Status Byte
 3e2:	80 91 c3 08 	lds	r24, 0x08C3	; 0x8008c3 <__TEXT_REGION_LENGTH__+0x7008c3>

    PORTE.OUTSET = PIN4_bm;			// Make SS high to stop communication
 3e6:	90 e1       	ldi	r25, 0x10	; 16
 3e8:	90 93 85 06 	sts	0x0685, r25	; 0x800685 <__TEXT_REGION_LENGTH__+0x700685>

    return x;
}
 3ec:	08 95       	ret

000003ee <ccxxx0_ReadBurst>:

void ccxxx0_ReadBurst(unsigned char addr, unsigned char* dataPtr, unsigned int dataCount)		// - DONE
{
 3ee:	cf 93       	push	r28
 3f0:	df 93       	push	r29
	unsigned char x;

	PORTE.OUTCLR = PIN4_bm; // make the SS pin low to start the communication
 3f2:	90 e1       	ldi	r25, 0x10	; 16
 3f4:	90 93 86 06 	sts	0x0686, r25	; 0x800686 <__TEXT_REGION_LENGTH__+0x700686>

	while(PORTE.IN & PIN6_bm);
 3f8:	e0 e8       	ldi	r30, 0x80	; 128
 3fa:	f6 e0       	ldi	r31, 0x06	; 6
 3fc:	90 85       	ldd	r25, Z+8	; 0x08
 3fe:	96 fd       	sbrc	r25, 6
 400:	fd cf       	rjmp	.-6      	; 0x3fc <ccxxx0_ReadBurst+0xe>

    SPIC_DATA = (addr | 0xc0); // Header Byte R/~W bit - 1 Burst bit - 1
 402:	80 6c       	ori	r24, 0xC0	; 192
 404:	80 93 c3 08 	sts	0x08C3, r24	; 0x8008c3 <__TEXT_REGION_LENGTH__+0x7008c3>
	while(!(SPIC_STATUS & PIN7_bm));
 408:	e2 ec       	ldi	r30, 0xC2	; 194
 40a:	f8 e0       	ldi	r31, 0x08	; 8
 40c:	80 81       	ld	r24, Z
 40e:	88 23       	and	r24, r24
 410:	ec f7       	brge	.-6      	; 0x40c <__LOCK_REGION_LENGTH__+0xc>
	x = SPIC_DATA;// flush SPDR
 412:	80 91 c3 08 	lds	r24, 0x08C3	; 0x8008c3 <__TEXT_REGION_LENGTH__+0x7008c3>

	while(dataCount) { // Loop that stops communication when desired number of bytes are read
 416:	41 15       	cp	r20, r1
 418:	51 05       	cpc	r21, r1
 41a:	81 f0       	breq	.+32     	; 0x43c <__LOCK_REGION_LENGTH__+0x3c>
 41c:	db 01       	movw	r26, r22
 41e:	46 0f       	add	r20, r22
 420:	57 1f       	adc	r21, r23
	    SPIC_DATA = 0;
 422:	c3 ec       	ldi	r28, 0xC3	; 195
 424:	d8 e0       	ldi	r29, 0x08	; 8
		while(!(SPIC_STATUS & PIN7_bm));
 426:	e2 ec       	ldi	r30, 0xC2	; 194
 428:	f8 e0       	ldi	r31, 0x08	; 8
    SPIC_DATA = (addr | 0xc0); // Header Byte R/~W bit - 1 Burst bit - 1
	while(!(SPIC_STATUS & PIN7_bm));
	x = SPIC_DATA;// flush SPDR

	while(dataCount) { // Loop that stops communication when desired number of bytes are read
	    SPIC_DATA = 0;
 42a:	18 82       	st	Y, r1
		while(!(SPIC_STATUS & PIN7_bm));
 42c:	80 81       	ld	r24, Z
 42e:	88 23       	and	r24, r24
 430:	ec f7       	brge	.-6      	; 0x42c <__LOCK_REGION_LENGTH__+0x2c>

	    *dataPtr++ = SPIC_DATA; // get data from SPDR, *dataPtr++ points the next element
 432:	88 81       	ld	r24, Y
 434:	8d 93       	st	X+, r24

    SPIC_DATA = (addr | 0xc0); // Header Byte R/~W bit - 1 Burst bit - 1
	while(!(SPIC_STATUS & PIN7_bm));
	x = SPIC_DATA;// flush SPDR

	while(dataCount) { // Loop that stops communication when desired number of bytes are read
 436:	a4 17       	cp	r26, r20
 438:	b5 07       	cpc	r27, r21
 43a:	b9 f7       	brne	.-18     	; 0x42a <__LOCK_REGION_LENGTH__+0x2a>

	    *dataPtr++ = SPIC_DATA; // get data from SPDR, *dataPtr++ points the next element
		dataCount--;
	}

    PORTE.OUTSET = PIN4_bm; // Make SS high to stop communication
 43c:	80 e1       	ldi	r24, 0x10	; 16
 43e:	80 93 85 06 	sts	0x0685, r24	; 0x800685 <__TEXT_REGION_LENGTH__+0x700685>
}
 442:	df 91       	pop	r29
 444:	cf 91       	pop	r28
 446:	08 95       	ret

00000448 <ccxxx0_WriteBurst>:

void ccxxx0_WriteBurst(unsigned char addr, unsigned char* dataPtr, unsigned int dataCount)			// - DONE
{
 448:	cf 93       	push	r28
 44a:	df 93       	push	r29
	unsigned char x;

	PORTE.OUTCLR = PIN4_bm; // make the SS pin low to start the communication
 44c:	90 e1       	ldi	r25, 0x10	; 16
 44e:	90 93 86 06 	sts	0x0686, r25	; 0x800686 <__TEXT_REGION_LENGTH__+0x700686>

	while(PORTE.IN & PIN6_bm);
 452:	e0 e8       	ldi	r30, 0x80	; 128
 454:	f6 e0       	ldi	r31, 0x06	; 6
 456:	90 85       	ldd	r25, Z+8	; 0x08
 458:	96 fd       	sbrc	r25, 6
 45a:	fd cf       	rjmp	.-6      	; 0x456 <ccxxx0_WriteBurst+0xe>

    SPIC_DATA = addr | 0x40; // Header Byte R/~W bit - 0 Burst bit - 1
 45c:	80 64       	ori	r24, 0x40	; 64
 45e:	80 93 c3 08 	sts	0x08C3, r24	; 0x8008c3 <__TEXT_REGION_LENGTH__+0x7008c3>
	while(!(SPIC_STATUS & PIN7_bm));
 462:	e2 ec       	ldi	r30, 0xC2	; 194
 464:	f8 e0       	ldi	r31, 0x08	; 8
 466:	80 81       	ld	r24, Z
 468:	88 23       	and	r24, r24
 46a:	ec f7       	brge	.-6      	; 0x466 <ccxxx0_WriteBurst+0x1e>
	x = SPIC_DATA; // flush SPDR
 46c:	80 91 c3 08 	lds	r24, 0x08C3	; 0x8008c3 <__TEXT_REGION_LENGTH__+0x7008c3>

	while(dataCount) { // Loop that stops communication after desired number of writing cycles
 470:	41 15       	cp	r20, r1
 472:	51 05       	cpc	r21, r1
 474:	79 f0       	breq	.+30     	; 0x494 <ccxxx0_WriteBurst+0x4c>
 476:	db 01       	movw	r26, r22
 478:	46 0f       	add	r20, r22
 47a:	57 1f       	adc	r21, r23
	    SPIC_DATA = *dataPtr++;
 47c:	c3 ec       	ldi	r28, 0xC3	; 195
 47e:	d8 e0       	ldi	r29, 0x08	; 8
		while(!(SPIC_STATUS & PIN7_bm));
 480:	e2 ec       	ldi	r30, 0xC2	; 194
 482:	f8 e0       	ldi	r31, 0x08	; 8
    SPIC_DATA = addr | 0x40; // Header Byte R/~W bit - 0 Burst bit - 1
	while(!(SPIC_STATUS & PIN7_bm));
	x = SPIC_DATA; // flush SPDR

	while(dataCount) { // Loop that stops communication after desired number of writing cycles
	    SPIC_DATA = *dataPtr++;
 484:	8d 91       	ld	r24, X+
 486:	88 83       	st	Y, r24
		while(!(SPIC_STATUS & PIN7_bm));
 488:	80 81       	ld	r24, Z
 48a:	88 23       	and	r24, r24
 48c:	ec f7       	brge	.-6      	; 0x488 <ccxxx0_WriteBurst+0x40>

    SPIC_DATA = addr | 0x40; // Header Byte R/~W bit - 0 Burst bit - 1
	while(!(SPIC_STATUS & PIN7_bm));
	x = SPIC_DATA; // flush SPDR

	while(dataCount) { // Loop that stops communication after desired number of writing cycles
 48e:	a4 17       	cp	r26, r20
 490:	b5 07       	cpc	r27, r21
 492:	c1 f7       	brne	.-16     	; 0x484 <ccxxx0_WriteBurst+0x3c>
		while(!(SPIC_STATUS & PIN7_bm));

		dataCount--;
	}

    PORTE.OUTSET = PIN4_bm; // Make SS high to stop communication
 494:	80 e1       	ldi	r24, 0x10	; 16
 496:	80 93 85 06 	sts	0x0685, r24	; 0x800685 <__TEXT_REGION_LENGTH__+0x700685>
}
 49a:	df 91       	pop	r29
 49c:	cf 91       	pop	r28
 49e:	08 95       	ret

000004a0 <ccxxx0_PowerOnReset>:

void ccxxx0_PowerOnReset() // Manual Reset		// - DONE
{
	unsigned char x;
	//datasheet cc1101 pg on.51 Manual Reset
    PORTE.OUTSET = PIN4_bm; // Make SS high
 4a0:	e0 e8       	ldi	r30, 0x80	; 128
 4a2:	f6 e0       	ldi	r31, 0x06	; 6
 4a4:	80 e1       	ldi	r24, 0x10	; 16
 4a6:	85 83       	std	Z+5, r24	; 0x05
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 4a8:	00 c0       	rjmp	.+0      	; 0x4aa <ccxxx0_PowerOnReset+0xa>
	_delay_us(1);								// ** Check how much delay we need in ATXMega corresponding to these functions **
	PORTE.OUTCLR = PIN4_bm; // Make SS low
 4aa:	86 83       	std	Z+6, r24	; 0x06
 4ac:	00 c0       	rjmp	.+0      	; 0x4ae <ccxxx0_PowerOnReset+0xe>
	_delay_us(1);
    PORTE.OUTSET = PIN4_bm; // Make SS high for atleast 41 us
 4ae:	85 83       	std	Z+5, r24	; 0x05
 4b0:	9b e1       	ldi	r25, 0x1B	; 27
 4b2:	9a 95       	dec	r25
 4b4:	f1 f7       	brne	.-4      	; 0x4b2 <ccxxx0_PowerOnReset+0x12>
 4b6:	00 00       	nop
	_delay_us(41);

	PORTE.OUTCLR = PIN4_bm; // Make SS low
 4b8:	86 83       	std	Z+6, r24	; 0x06

	while(PORTE.IN & PIN6_bm); // wait for SO to go low
 4ba:	80 85       	ldd	r24, Z+8	; 0x08
 4bc:	86 fd       	sbrc	r24, 6
 4be:	fd cf       	rjmp	.-6      	; 0x4ba <ccxxx0_PowerOnReset+0x1a>
 4c0:	81 e2       	ldi	r24, 0x21	; 33
 4c2:	8a 95       	dec	r24
 4c4:	f1 f7       	brne	.-4      	; 0x4c2 <ccxxx0_PowerOnReset+0x22>
 4c6:	00 00       	nop

	_delay_us(50);

    SPIC_DATA = CCxxx0_SRES; // Isssue the SRES command strobe
 4c8:	80 e3       	ldi	r24, 0x30	; 48
 4ca:	80 93 c3 08 	sts	0x08C3, r24	; 0x8008c3 <__TEXT_REGION_LENGTH__+0x7008c3>
	while(!(SPIC_STATUS & PIN7_bm));
 4ce:	e2 ec       	ldi	r30, 0xC2	; 194
 4d0:	f8 e0       	ldi	r31, 0x08	; 8
 4d2:	80 81       	ld	r24, Z
 4d4:	88 23       	and	r24, r24
 4d6:	ec f7       	brge	.-6      	; 0x4d2 <ccxxx0_PowerOnReset+0x32>
	x = SPIC_DATA; // flush SPDR
 4d8:	80 91 c3 08 	lds	r24, 0x08C3	; 0x8008c3 <__TEXT_REGION_LENGTH__+0x7008c3>

	while(PORTE.IN & PIN6_bm); // When SO goes low again, reset is complete
 4dc:	e0 e8       	ldi	r30, 0x80	; 128
 4de:	f6 e0       	ldi	r31, 0x06	; 6
 4e0:	80 85       	ldd	r24, Z+8	; 0x08
 4e2:	86 fd       	sbrc	r24, 6
 4e4:	fd cf       	rjmp	.-6      	; 0x4e0 <ccxxx0_PowerOnReset+0x40>
 4e6:	91 e2       	ldi	r25, 0x21	; 33
 4e8:	9a 95       	dec	r25
 4ea:	f1 f7       	brne	.-4      	; 0x4e8 <ccxxx0_PowerOnReset+0x48>
 4ec:	00 00       	nop

// **THE CHIP IS IDLE STATE AFTER RESET**

	_delay_us(50);

    PORTE.OUTSET = PIN4_bm; // Make SS high
 4ee:	80 e1       	ldi	r24, 0x10	; 16
 4f0:	80 93 85 06 	sts	0x0685, r24	; 0x800685 <__TEXT_REGION_LENGTH__+0x700685>
 4f4:	08 95       	ret

000004f6 <transmit_USART>:
}

void transmit_USART(char data)
{
 4f6:	cf 93       	push	r28
 4f8:	df 93       	push	r29
	uint8_t i;
	PORTC.DIRSET   = PIN3_bm;
 4fa:	e0 e4       	ldi	r30, 0x40	; 64
 4fc:	f6 e0       	ldi	r31, 0x06	; 6
 4fe:	98 e0       	ldi	r25, 0x08	; 8
 500:	91 83       	std	Z+1, r25	; 0x01
	PORTC.DIRCLR   = PIN2_bm;
 502:	94 e0       	ldi	r25, 0x04	; 4
 504:	92 83       	std	Z+2, r25	; 0x02
 */
void USART_InterruptDriver_Initialize(USART_data_t * usart_data,
                                      USART_t * usart,
                                      USART_DREINTLVL_t dreIntLevel)
{
	usart_data->usart = usart;
 506:	a9 ee       	ldi	r26, 0xE9	; 233
 508:	b0 e2       	ldi	r27, 0x20	; 32
 50a:	e0 ea       	ldi	r30, 0xA0	; 160
 50c:	f8 e0       	ldi	r31, 0x08	; 8
 50e:	ed 93       	st	X+, r30
 510:	fc 93       	st	X, r31
 512:	11 97       	sbiw	r26, 0x01	; 1
	usart_data->dreIntLevel = dreIntLevel;
 514:	91 e0       	ldi	r25, 0x01	; 1
 516:	12 96       	adiw	r26, 0x02	; 2
 518:	9c 93       	st	X, r25
 51a:	12 97       	sbiw	r26, 0x02	; 2

	usart_data->buffer.RX_Tail = 0;
 51c:	1c 96       	adiw	r26, 0x0c	; 12
 51e:	1c 92       	st	X, r1
 520:	1c 97       	sbiw	r26, 0x0c	; 12
	usart_data->buffer.RX_Head = 0;
 522:	1b 96       	adiw	r26, 0x0b	; 11
 524:	1c 92       	st	X, r1
 526:	1b 97       	sbiw	r26, 0x0b	; 11
	usart_data->buffer.TX_Tail = 0;
 528:	1e 96       	adiw	r26, 0x0e	; 14
 52a:	1c 92       	st	X, r1
 52c:	1e 97       	sbiw	r26, 0x0e	; 14
	usart_data->buffer.TX_Head = 0;
 52e:	1d 96       	adiw	r26, 0x0d	; 13
 530:	1c 92       	st	X, r1
	/* Use USARTC0 and initialize buffers. */
	USART_InterruptDriver_Initialize(&USART_data, &USART, USART_DREINTLVL_LO_gc);

	/* USARTC0, 8 Data bits, No Parity, 1 Stop bit. */
	USART_Format_Set(USART_data.usart, USART_CHSIZE_8BIT_gc,
 532:	93 e0       	ldi	r25, 0x03	; 3
 534:	95 83       	std	Z+5, r25	; 0x05
	USART_PMODE_DISABLED_gc, false);

	/* Enable RXC interrupt. */
	USART_RxdInterruptLevel_Set(USART_data.usart, USART_RXCINTLVL_LO_gc);
 536:	93 81       	ldd	r25, Z+3	; 0x03
 538:	9f 7c       	andi	r25, 0xCF	; 207
 53a:	90 61       	ori	r25, 0x10	; 16
 53c:	93 83       	std	Z+3, r25	; 0x03
	USART_Baudrate_Set(&USART, 12 , 0);
 53e:	9c e0       	ldi	r25, 0x0C	; 12
 540:	96 83       	std	Z+6, r25	; 0x06
 542:	17 82       	std	Z+7, r1	; 0x07

	/* Enable both RX and TX. */
	USART_Rx_Enable(USART_data.usart);
 544:	94 81       	ldd	r25, Z+4	; 0x04
 546:	90 61       	ori	r25, 0x10	; 16
 548:	94 83       	std	Z+4, r25	; 0x04
	USART_Tx_Enable(USART_data.usart);
 54a:	94 81       	ldd	r25, Z+4	; 0x04
 54c:	98 60       	ori	r25, 0x08	; 8
 54e:	94 83       	std	Z+4, r25	; 0x04

	/* Enable PMIC interrupt level low. */
	PMIC.CTRL |= PMIC_LOLVLEX_bm;
 550:	e0 ea       	ldi	r30, 0xA0	; 160
 552:	f0 e0       	ldi	r31, 0x00	; 0
 554:	92 81       	ldd	r25, Z+2	; 0x02
 556:	91 60       	ori	r25, 0x01	; 1
 558:	92 83       	std	Z+2, r25	; 0x02

	/* Enable global interrupts. */
	sei();
 55a:	78 94       	sei

	/* Send sendArray. */
	sendArray[0]=data;
 55c:	80 93 6c 20 	sts	0x206C, r24	; 0x80206c <sendArray>
	i = 0;
	while (i < 1) {
		bool Tobuffer;
		Tobuffer=	USART_TXBuffer_PutByte(&USART_data, sendArray[i]);
 560:	cc e6       	ldi	r28, 0x6C	; 108
 562:	d0 e2       	ldi	r29, 0x20	; 32
 564:	68 81       	ld	r22, Y
 566:	89 ee       	ldi	r24, 0xE9	; 233
 568:	90 e2       	ldi	r25, 0x20	; 32
 56a:	0e 94 58 01 	call	0x2b0	; 0x2b0 <USART_TXBuffer_PutByte>
	sei();

	/* Send sendArray. */
	sendArray[0]=data;
	i = 0;
	while (i < 1) {
 56e:	88 23       	and	r24, r24
 570:	c9 f3       	breq	.-14     	; 0x564 <transmit_USART+0x6e>
		
		if(Tobuffer){
			i++;
		}
	}
}
 572:	df 91       	pop	r29
 574:	cf 91       	pop	r28
 576:	08 95       	ret

00000578 <transmit_string_USART>:

void transmit_string_USART(char *string)
{
 578:	cf 93       	push	r28
 57a:	bc 01       	movw	r22, r24
	uint8_t i;
	PORTC.DIRSET   = PIN3_bm;
 57c:	e0 e4       	ldi	r30, 0x40	; 64
 57e:	f6 e0       	ldi	r31, 0x06	; 6
 580:	88 e0       	ldi	r24, 0x08	; 8
 582:	81 83       	std	Z+1, r24	; 0x01
	PORTC.DIRCLR   = PIN2_bm;
 584:	84 e0       	ldi	r24, 0x04	; 4
 586:	82 83       	std	Z+2, r24	; 0x02
 */
void USART_InterruptDriver_Initialize(USART_data_t * usart_data,
                                      USART_t * usart,
                                      USART_DREINTLVL_t dreIntLevel)
{
	usart_data->usart = usart;
 588:	a9 ee       	ldi	r26, 0xE9	; 233
 58a:	b0 e2       	ldi	r27, 0x20	; 32
 58c:	e0 ea       	ldi	r30, 0xA0	; 160
 58e:	f8 e0       	ldi	r31, 0x08	; 8
 590:	ed 93       	st	X+, r30
 592:	fc 93       	st	X, r31
 594:	11 97       	sbiw	r26, 0x01	; 1
	usart_data->dreIntLevel = dreIntLevel;
 596:	81 e0       	ldi	r24, 0x01	; 1
 598:	12 96       	adiw	r26, 0x02	; 2
 59a:	8c 93       	st	X, r24
 59c:	12 97       	sbiw	r26, 0x02	; 2

	usart_data->buffer.RX_Tail = 0;
 59e:	1c 96       	adiw	r26, 0x0c	; 12
 5a0:	1c 92       	st	X, r1
 5a2:	1c 97       	sbiw	r26, 0x0c	; 12
	usart_data->buffer.RX_Head = 0;
 5a4:	1b 96       	adiw	r26, 0x0b	; 11
 5a6:	1c 92       	st	X, r1
 5a8:	1b 97       	sbiw	r26, 0x0b	; 11
	usart_data->buffer.TX_Tail = 0;
 5aa:	1e 96       	adiw	r26, 0x0e	; 14
 5ac:	1c 92       	st	X, r1
 5ae:	1e 97       	sbiw	r26, 0x0e	; 14
	usart_data->buffer.TX_Head = 0;
 5b0:	1d 96       	adiw	r26, 0x0d	; 13
 5b2:	1c 92       	st	X, r1
	/* Use USARTC0 and initialize buffers. */
	USART_InterruptDriver_Initialize(&USART_data, &USART, USART_DREINTLVL_LO_gc);

	/* USARTC0, 8 Data bits, No Parity, 1 Stop bit. */
	USART_Format_Set(USART_data.usart, USART_CHSIZE_8BIT_gc,
 5b4:	83 e0       	ldi	r24, 0x03	; 3
 5b6:	85 83       	std	Z+5, r24	; 0x05
	USART_PMODE_DISABLED_gc, false);

	/* Enable RXC interrupt. */
	USART_RxdInterruptLevel_Set(USART_data.usart, USART_RXCINTLVL_LO_gc);
 5b8:	93 81       	ldd	r25, Z+3	; 0x03
 5ba:	9f 7c       	andi	r25, 0xCF	; 207
 5bc:	90 61       	ori	r25, 0x10	; 16
 5be:	93 83       	std	Z+3, r25	; 0x03
	USART_Baudrate_Set(&USART, 12 , 0);
 5c0:	8c e0       	ldi	r24, 0x0C	; 12
 5c2:	86 83       	std	Z+6, r24	; 0x06
 5c4:	17 82       	std	Z+7, r1	; 0x07

	/* Enable both RX and TX. */
	USART_Rx_Enable(USART_data.usart);
 5c6:	94 81       	ldd	r25, Z+4	; 0x04
 5c8:	90 61       	ori	r25, 0x10	; 16
 5ca:	94 83       	std	Z+4, r25	; 0x04
	USART_Tx_Enable(USART_data.usart);
 5cc:	94 81       	ldd	r25, Z+4	; 0x04
 5ce:	98 60       	ori	r25, 0x08	; 8
 5d0:	94 83       	std	Z+4, r25	; 0x04

	/* Enable PMIC interrupt level low. */
	PMIC.CTRL |= PMIC_LOLVLEX_bm;
 5d2:	e0 ea       	ldi	r30, 0xA0	; 160
 5d4:	f0 e0       	ldi	r31, 0x00	; 0
 5d6:	92 81       	ldd	r25, Z+2	; 0x02
 5d8:	91 60       	ori	r25, 0x01	; 1
 5da:	92 83       	std	Z+2, r25	; 0x02

	/* Enable global interrupts. */
	sei();
 5dc:	78 94       	sei

	/* Send sendArray. */
	strcpy(sendArray,string);
 5de:	8c e6       	ldi	r24, 0x6C	; 108
 5e0:	90 e2       	ldi	r25, 0x20	; 32
 5e2:	0e 94 57 04 	call	0x8ae	; 0x8ae <strcpy>
	i = 0;
 5e6:	c0 e0       	ldi	r28, 0x00	; 0
	while (i < 61) {
		bool Tobuffer;
		Tobuffer=	USART_TXBuffer_PutByte(&USART_data, sendArray[i]);
 5e8:	ec 2f       	mov	r30, r28
 5ea:	f0 e0       	ldi	r31, 0x00	; 0
 5ec:	e4 59       	subi	r30, 0x94	; 148
 5ee:	ff 4d       	sbci	r31, 0xDF	; 223
 5f0:	60 81       	ld	r22, Z
 5f2:	89 ee       	ldi	r24, 0xE9	; 233
 5f4:	90 e2       	ldi	r25, 0x20	; 32
 5f6:	0e 94 58 01 	call	0x2b0	; 0x2b0 <USART_TXBuffer_PutByte>
		
		if(Tobuffer){
 5fa:	81 11       	cpse	r24, r1
			i++;
 5fc:	cf 5f       	subi	r28, 0xFF	; 255
	sei();

	/* Send sendArray. */
	strcpy(sendArray,string);
	i = 0;
	while (i < 61) {
 5fe:	cd 33       	cpi	r28, 0x3D	; 61
 600:	98 f3       	brcs	.-26     	; 0x5e8 <transmit_string_USART+0x70>
		
		if(Tobuffer){
			i++;
		}
	}
}
 602:	cf 91       	pop	r28
 604:	08 95       	ret

00000606 <ccxxx0_Setup>:
{
	unsigned char read;
	// Write register settings
	
	//writeByte = 0x08;
	ccxxx0_Write(CC112X_IOCFG3, 0x08);
 606:	68 e0       	ldi	r22, 0x08	; 8
 608:	80 e0       	ldi	r24, 0x00	; 0
 60a:	0e 94 c4 01 	call	0x388	; 0x388 <ccxxx0_Write>
	//writeByte = 0x09;
	ccxxx0_Write(CC112X_IOCFG2, 0x09);
 60e:	69 e0       	ldi	r22, 0x09	; 9
 610:	81 e0       	ldi	r24, 0x01	; 1
 612:	0e 94 c4 01 	call	0x388	; 0x388 <ccxxx0_Write>
	//writeByte = 0x30;
	ccxxx0_Write(CC112X_IOCFG0, 0x30);
 616:	60 e3       	ldi	r22, 0x30	; 48
 618:	83 e0       	ldi	r24, 0x03	; 3
 61a:	0e 94 c4 01 	call	0x388	; 0x388 <ccxxx0_Write>
	//writeByte = 0x08;
	ccxxx0_Write(CC112X_SYNC_CFG1, 0x08);
 61e:	68 e0       	ldi	r22, 0x08	; 8
 620:	88 e0       	ldi	r24, 0x08	; 8
 622:	0e 94 c4 01 	call	0x388	; 0x388 <ccxxx0_Write>
	//writeByte = 0x00;
	ccxxx0_Write(CC112X_PREAMBLE_CFG1, 0x00);
 626:	60 e0       	ldi	r22, 0x00	; 0
 628:	8d e0       	ldi	r24, 0x0D	; 13
 62a:	0e 94 c4 01 	call	0x388	; 0x388 <ccxxx0_Write>
	//writeByte = 0x06;
	ccxxx0_Write(CC112X_MDMCFG1, 0x06);
 62e:	66 e0       	ldi	r22, 0x06	; 6
 630:	82 e1       	ldi	r24, 0x12	; 18
 632:	0e 94 c4 01 	call	0x388	; 0x388 <ccxxx0_Write>
	//writeByte = 0x0A;
	ccxxx0_Write(CC112X_MDMCFG0, 0x0A);
 636:	6a e0       	ldi	r22, 0x0A	; 10
 638:	83 e1       	ldi	r24, 0x13	; 19
 63a:	0e 94 c4 01 	call	0x388	; 0x388 <ccxxx0_Write>
	//writeByte = 0xA9;
	ccxxx0_Write(CC112X_AGC_CFG1, 0xA9);
 63e:	69 ea       	ldi	r22, 0xA9	; 169
 640:	8c e1       	ldi	r24, 0x1C	; 28
 642:	0e 94 c4 01 	call	0x388	; 0x388 <ccxxx0_Write>
	//writeByte = 0x05;
	ccxxx0_Write(CC112X_PKT_CFG2, 0x05);
 646:	65 e0       	ldi	r22, 0x05	; 5
 648:	86 e2       	ldi	r24, 0x26	; 38
 64a:	0e 94 c4 01 	call	0x388	; 0x388 <ccxxx0_Write>
	//writeByte = 0x00;
	ccxxx0_Write(CC112X_PKT_CFG1, 0x00);
 64e:	60 e0       	ldi	r22, 0x00	; 0
 650:	87 e2       	ldi	r24, 0x27	; 39
 652:	0e 94 c4 01 	call	0x388	; 0x388 <ccxxx0_Write>
	//writeByte = 0x08;
	ccxxx0_Write(CC112X_SERIAL_STATUS, 0x08);
 656:	68 e0       	ldi	r22, 0x08	; 8
 658:	81 e9       	ldi	r24, 0x91	; 145
 65a:	0e 94 c4 01 	call	0x388	; 0x388 <ccxxx0_Write>
	ccxxx0_Write(CC112X_MODCFG_DEV_E, 0x29);
 65e:	69 e2       	ldi	r22, 0x29	; 41
 660:	8b e0       	ldi	r24, 0x0B	; 11
 662:	0e 94 c4 01 	call	0x388	; 0x388 <ccxxx0_Write>
	ccxxx0_Write(CC112X_FREQ_IF_CFG, 0x50);
 666:	60 e5       	ldi	r22, 0x50	; 80
 668:	8f e0       	ldi	r24, 0x0F	; 15
 66a:	0e 94 c4 01 	call	0x388	; 0x388 <ccxxx0_Write>
	ccxxx0_Write(CC112X_SYMBOL_RATE2, 0x48);
 66e:	68 e4       	ldi	r22, 0x48	; 72
 670:	84 e1       	ldi	r24, 0x14	; 20
 672:	0e 94 c4 01 	call	0x388	; 0x388 <ccxxx0_Write>
	ccxxx0_Write(CC112X_SYMBOL_RATE1, 0x93);
 676:	63 e9       	ldi	r22, 0x93	; 147
 678:	85 e1       	ldi	r24, 0x15	; 21
 67a:	0e 94 c4 01 	call	0x388	; 0x388 <ccxxx0_Write>
	ccxxx0_Write(CC112X_SYMBOL_RATE0, 0x75);
 67e:	65 e7       	ldi	r22, 0x75	; 117
 680:	86 e1       	ldi	r24, 0x16	; 22
 682:	0e 94 c4 01 	call	0x388	; 0x388 <ccxxx0_Write>
	ccxxx0_Write(CC112X_FS_CFG, 0x7E);
 686:	6e e7       	ldi	r22, 0x7E	; 126
 688:	81 e2       	ldi	r24, 0x21	; 33
 68a:	0e 94 c4 01 	call	0x388	; 0x388 <ccxxx0_Write>
	ccxxx0_Write(CC112X_PA_CFG0, 0x7E);
 68e:	6e e7       	ldi	r22, 0x7E	; 126
 690:	8d e2       	ldi	r24, 0x2D	; 45
 692:	0e 94 c4 01 	call	0x388	; 0x388 <ccxxx0_Write>
	ccxxx0_Write(CC112X_FREQ2, 0x6D);
 696:	6d e6       	ldi	r22, 0x6D	; 109
 698:	8c e0       	ldi	r24, 0x0C	; 12
 69a:	0e 94 c4 01 	call	0x388	; 0x388 <ccxxx0_Write>
	ccxxx0_Write(CC112X_FREQ1, 0x7D);
 69e:	6d e7       	ldi	r22, 0x7D	; 125
 6a0:	8d e0       	ldi	r24, 0x0D	; 13
 6a2:	0e 94 c4 01 	call	0x388	; 0x388 <ccxxx0_Write>
	ccxxx0_Write(CC112X_FREQ0, 0x81);
 6a6:	61 e8       	ldi	r22, 0x81	; 129
 6a8:	8e e0       	ldi	r24, 0x0E	; 14
 6aa:	0e 94 c4 01 	call	0x388	; 0x388 <ccxxx0_Write>
 6ae:	08 95       	ret

000006b0 <CC_Receive>:
	transmit_USART(read);*/
}


void CC_Receive()				// - DONE
{
 6b0:	cf 93       	push	r28
 6b2:	df 93       	push	r29
 6b4:	cd b7       	in	r28, 0x3d	; 61
 6b6:	de b7       	in	r29, 0x3e	; 62
 6b8:	ee 97       	sbiw	r28, 0x3e	; 62
 6ba:	cd bf       	out	0x3d, r28	; 61
 6bc:	de bf       	out	0x3e, r29	; 62
	transmit_enable = 0;
 6be:	10 92 2e 20 	sts	0x202E, r1	; 0x80202e <__data_end>
	unsigned char temp[62];
	ccxxx0_Strobe(CCxxx0_SIDLE);//Exit RX / TX, turn off frequency synthesizer and exit Wake-On-Radio mode if applicable
 6c2:	86 e3       	ldi	r24, 0x36	; 54
 6c4:	0e 94 e2 01 	call	0x3c4	; 0x3c4 <ccxxx0_Strobe>
	ccxxx0_WriteBurst(CCxxx0_PATABLE, &paTable[0], 1); // max power
 6c8:	41 e0       	ldi	r20, 0x01	; 1
 6ca:	50 e0       	ldi	r21, 0x00	; 0
 6cc:	60 e0       	ldi	r22, 0x00	; 0
 6ce:	70 e2       	ldi	r23, 0x20	; 32
 6d0:	8e e3       	ldi	r24, 0x3E	; 62
 6d2:	0e 94 24 02 	call	0x448	; 0x448 <ccxxx0_WriteBurst>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 6d6:	83 ef       	ldi	r24, 0xF3	; 243
 6d8:	91 e0       	ldi	r25, 0x01	; 1
 6da:	01 97       	sbiw	r24, 0x01	; 1
 6dc:	f1 f7       	brne	.-4      	; 0x6da <CC_Receive+0x2a>
 6de:	00 c0       	rjmp	.+0      	; 0x6e0 <CC_Receive+0x30>
 6e0:	00 00       	nop
	_delay_ms(1);
	ccxxx0_Strobe(CCxxx0_SFRX); // flush rx buff
 6e2:	8a e3       	ldi	r24, 0x3A	; 58
 6e4:	0e 94 e2 01 	call	0x3c4	; 0x3c4 <ccxxx0_Strobe>
	ccxxx0_Strobe(CCxxx0_SRX);// goto rx mode
 6e8:	84 e3       	ldi	r24, 0x34	; 52
 6ea:	0e 94 e2 01 	call	0x3c4	; 0x3c4 <ccxxx0_Strobe>
	{
		char bytes_RXFIFO = ccxxx0_Read(CCxxx0_RXBYTES);

		//transmit_string_USART("Hello2");

		if(PORTE.IN & (1 << CC_GPIO0))
 6ee:	00 e8       	ldi	r16, 0x80	; 128
 6f0:	16 e0       	ldi	r17, 0x06	; 6
 6f2:	7e 01       	movw	r14, r28
 6f4:	9b e3       	ldi	r25, 0x3B	; 59
 6f6:	e9 0e       	add	r14, r25
 6f8:	f1 1c       	adc	r15, r1
			if ((temp[1] == 'C')&&(temp[2] == 'Q')){ // 'A' in binary is 01000001
				transmit_string_USART("Entered if \n");
			for(int i=0;i<34;i++) {
				data[i] = temp[24+i];
			}
			data[35]='\0';
 6fa:	0f 2e       	mov	r0, r31
 6fc:	ff e4       	ldi	r31, 0x4F	; 79
 6fe:	4f 2e       	mov	r4, r31
 700:	f1 e2       	ldi	r31, 0x21	; 33
 702:	5f 2e       	mov	r5, r31
 704:	f0 2d       	mov	r31, r0
			//	transmit_string_USART("Frame Received with no errors\r\n");
				_delay_ms(5);
				//transmit_string_USART("Data = ");
				_delay_ms(5);
				//transmit_string_USART(data);
				data[34] = 'm';
 706:	0f 2e       	mov	r0, r31
 708:	fd e6       	ldi	r31, 0x6D	; 109
 70a:	7f 2e       	mov	r7, r31
 70c:	f0 2d       	mov	r31, r0
 70e:	0f 2e       	mov	r0, r31
 710:	f2 e7       	ldi	r31, 0x72	; 114
 712:	af 2e       	mov	r10, r31
 714:	f1 e2       	ldi	r31, 0x21	; 33
 716:	bf 2e       	mov	r11, r31
 718:	f0 2d       	mov	r31, r0
				for(int i =0; i<35; i++){
					transmit_USART(data[i]);
				}
				_delay_ms(5);
				transmit_USART("\n");
 71a:	0f 2e       	mov	r0, r31
 71c:	fb e2       	ldi	r31, 0x2B	; 43
 71e:	8f 2e       	mov	r8, r31
 720:	f0 e2       	ldi	r31, 0x20	; 32
 722:	9f 2e       	mov	r9, r31
 724:	f0 2d       	mov	r31, r0
	ccxxx0_Strobe(CCxxx0_SFRX); // flush rx buff
	ccxxx0_Strobe(CCxxx0_SRX);// goto rx mode

	while(1)
	{
		char bytes_RXFIFO = ccxxx0_Read(CCxxx0_RXBYTES);
 726:	8b ef       	ldi	r24, 0xFB	; 251
 728:	0e 94 a5 01 	call	0x34a	; 0x34a <ccxxx0_Read>

		//transmit_string_USART("Hello2");

		if(PORTE.IN & (1 << CC_GPIO0))
 72c:	f8 01       	movw	r30, r16
 72e:	80 85       	ldd	r24, Z+8	; 0x08
 730:	80 ff       	sbrs	r24, 0
 732:	f9 cf       	rjmp	.-14     	; 0x726 <CC_Receive+0x76>
		{
			//transmit_string_USART("package available \n");
			//transmit_string_USART("Hello1");
			while(PORTE.IN & (1 << CC_GPIO0)){
 734:	f8 01       	movw	r30, r16
 736:	80 85       	ldd	r24, Z+8	; 0x08
 738:	80 fd       	sbrc	r24, 0
 73a:	fc cf       	rjmp	.-8      	; 0x734 <CC_Receive+0x84>
				//transmit_string_USART("in");
			}
			//char bytes_RXFIFO = ccxxx0_Read(CCxxx0_RXBYTES);
			//transmit_string_USART("Hello");
			char bytes_RXFIFO = ccxxx0_Read(CCxxx0_RXBYTES);
 73c:	8b ef       	ldi	r24, 0xFB	; 251
 73e:	0e 94 a5 01 	call	0x34a	; 0x34a <ccxxx0_Read>
			}*/


			//for(int i =0; i<35; i++){
			//temp[i] = ccxxx0_Read(CCxxx0_RXFIFO);}
			ccxxx0_ReadBurst(CCxxx0_RXFIFO, temp,61);
 742:	4d e3       	ldi	r20, 0x3D	; 61
 744:	50 e0       	ldi	r21, 0x00	; 0
 746:	be 01       	movw	r22, r28
 748:	6f 5f       	subi	r22, 0xFF	; 255
 74a:	7f 4f       	sbci	r23, 0xFF	; 255
 74c:	8f e3       	ldi	r24, 0x3F	; 63
 74e:	0e 94 f7 01 	call	0x3ee	; 0x3ee <ccxxx0_ReadBurst>
			//transmit_string_USART("RXed data: ");
			ccxxx0_Strobe(CCxxx0_SFRX); // flush rx buf
 752:	8a e3       	ldi	r24, 0x3A	; 58
 754:	0e 94 e2 01 	call	0x3c4	; 0x3c4 <ccxxx0_Strobe>
			ccxxx0_Strobe(CCxxx0_SRX); // goto rx mode
 758:	84 e3       	ldi	r24, 0x34	; 52
 75a:	0e 94 e2 01 	call	0x3c4	; 0x3c4 <ccxxx0_Strobe>
			/*for(int i = 0; i< 39; i++){
				transmit_USART(temp[i]);
			}
			*/
			//transmit_string_USART("About to Enter \n");
			if ((temp[1] == 'C')&&(temp[2] == 'Q')){ // 'A' in binary is 01000001
 75e:	8a 81       	ldd	r24, Y+2	; 0x02
 760:	83 34       	cpi	r24, 0x43	; 67
 762:	09 f0       	breq	.+2      	; 0x766 <CC_Receive+0xb6>
 764:	6a c0       	rjmp	.+212    	; 0x83a <CC_Receive+0x18a>
 766:	8b 81       	ldd	r24, Y+3	; 0x03
 768:	81 35       	cpi	r24, 0x51	; 81
 76a:	09 f0       	breq	.+2      	; 0x76e <CC_Receive+0xbe>
 76c:	66 c0       	rjmp	.+204    	; 0x83a <CC_Receive+0x18a>
				transmit_string_USART("Entered if \n");
 76e:	86 e1       	ldi	r24, 0x16	; 22
 770:	90 e2       	ldi	r25, 0x20	; 32
 772:	0e 94 bc 02 	call	0x578	; 0x578 <transmit_string_USART>
 776:	fe 01       	movw	r30, r28
 778:	79 96       	adiw	r30, 0x19	; 25
 77a:	0f 2e       	mov	r0, r31
 77c:	ff e4       	ldi	r31, 0x4F	; 79
 77e:	cf 2e       	mov	r12, r31
 780:	f1 e2       	ldi	r31, 0x21	; 33
 782:	df 2e       	mov	r13, r31
 784:	f0 2d       	mov	r31, r0
 786:	d6 01       	movw	r26, r12
			for(int i=0;i<34;i++) {
				data[i] = temp[24+i];
 788:	81 91       	ld	r24, Z+
 78a:	8d 93       	st	X+, r24
			}
			*/
			//transmit_string_USART("About to Enter \n");
			if ((temp[1] == 'C')&&(temp[2] == 'Q')){ // 'A' in binary is 01000001
				transmit_string_USART("Entered if \n");
			for(int i=0;i<34;i++) {
 78c:	ee 15       	cp	r30, r14
 78e:	ff 05       	cpc	r31, r15
 790:	d9 f7       	brne	.-10     	; 0x788 <CC_Receive+0xd8>
				data[i] = temp[24+i];
			}
			data[35]='\0';
 792:	f2 01       	movw	r30, r4
 794:	13 a2       	std	Z+35, r1	; 0x23

			uint8_t *framePtr;
			framePtr = temp;
			crc = crc16(temp+1,57);
 796:	69 e3       	ldi	r22, 0x39	; 57
 798:	ce 01       	movw	r24, r28
 79a:	02 96       	adiw	r24, 0x02	; 2
 79c:	0e 94 21 01 	call	0x242	; 0x242 <crc16>
 7a0:	80 93 e7 20 	sts	0x20E7, r24	; 0x8020e7 <crc>
 7a4:	90 93 e8 20 	sts	0x20E8, r25	; 0x8020e8 <crc+0x1>
 7a8:	83 ec       	ldi	r24, 0xC3	; 195
 7aa:	99 e0       	ldi	r25, 0x09	; 9
 7ac:	01 97       	sbiw	r24, 0x01	; 1
 7ae:	f1 f7       	brne	.-4      	; 0x7ac <CC_Receive+0xfc>
 7b0:	00 c0       	rjmp	.+0      	; 0x7b2 <CC_Receive+0x102>
 7b2:	00 00       	nop
			//transmit_string_USART("CRC Computed=\r\n");
			_delay_ms(5);
			crc1 = crc;
 7b4:	90 91 e7 20 	lds	r25, 0x20E7	; 0x8020e7 <crc>
 7b8:	80 91 e8 20 	lds	r24, 0x20E8	; 0x8020e8 <crc+0x1>
 7bc:	90 93 e6 20 	sts	0x20E6, r25	; 0x8020e6 <crc1>
			crc2 = (crc>>8);
 7c0:	80 93 9a 21 	sts	0x219A, r24	; 0x80219a <crc2>
 7c4:	e7 e8       	ldi	r30, 0x87	; 135
 7c6:	f3 e1       	ldi	r31, 0x13	; 19
 7c8:	31 97       	sbiw	r30, 0x01	; 1
 7ca:	f1 f7       	brne	.-4      	; 0x7c8 <CC_Receive+0x118>
 7cc:	00 c0       	rjmp	.+0      	; 0x7ce <CC_Receive+0x11e>
 7ce:	00 00       	nop
 7d0:	83 ec       	ldi	r24, 0xC3	; 195
 7d2:	99 e0       	ldi	r25, 0x09	; 9
 7d4:	01 97       	sbiw	r24, 0x01	; 1
 7d6:	f1 f7       	brne	.-4      	; 0x7d4 <CC_Receive+0x124>
 7d8:	00 c0       	rjmp	.+0      	; 0x7da <CC_Receive+0x12a>
 7da:	00 00       	nop
 7dc:	e7 e8       	ldi	r30, 0x87	; 135
 7de:	f3 e1       	ldi	r31, 0x13	; 19
 7e0:	31 97       	sbiw	r30, 0x01	; 1
 7e2:	f1 f7       	brne	.-4      	; 0x7e0 <CC_Receive+0x130>
 7e4:	00 c0       	rjmp	.+0      	; 0x7e6 <CC_Receive+0x136>
 7e6:	00 00       	nop
			//transmit_USART(temp[59]);
			_delay_ms(10);
			//transmit_string_UART("Now checking equality of the CRCs\r\n");
			//_delay_ms(5);
			//Check if CRCs match
			if((crc1==temp[58])&&(crc2==temp[59])){
 7e8:	9b ad       	ldd	r25, Y+59	; 0x3b
 7ea:	80 91 e6 20 	lds	r24, 0x20E6	; 0x8020e6 <crc1>
 7ee:	98 13       	cpse	r25, r24
 7f0:	24 c0       	rjmp	.+72     	; 0x83a <CC_Receive+0x18a>
 7f2:	9c ad       	ldd	r25, Y+60	; 0x3c
 7f4:	80 91 9a 21 	lds	r24, 0x219A	; 0x80219a <crc2>
 7f8:	98 13       	cpse	r25, r24
 7fa:	1f c0       	rjmp	.+62     	; 0x83a <CC_Receive+0x18a>
 7fc:	83 ec       	ldi	r24, 0xC3	; 195
 7fe:	99 e0       	ldi	r25, 0x09	; 9
 800:	01 97       	sbiw	r24, 0x01	; 1
 802:	f1 f7       	brne	.-4      	; 0x800 <CC_Receive+0x150>
 804:	00 c0       	rjmp	.+0      	; 0x806 <CC_Receive+0x156>
 806:	00 00       	nop
 808:	e3 ec       	ldi	r30, 0xC3	; 195
 80a:	f9 e0       	ldi	r31, 0x09	; 9
 80c:	31 97       	sbiw	r30, 0x01	; 1
 80e:	f1 f7       	brne	.-4      	; 0x80c <CC_Receive+0x15c>
 810:	00 c0       	rjmp	.+0      	; 0x812 <CC_Receive+0x162>
 812:	00 00       	nop
			//	transmit_string_USART("Frame Received with no errors\r\n");
				_delay_ms(5);
				//transmit_string_USART("Data = ");
				_delay_ms(5);
				//transmit_string_USART(data);
				data[34] = 'm';
 814:	f2 01       	movw	r30, r4
 816:	72 a2       	std	Z+34, r7	; 0x22
				for(int i =0; i<35; i++){
					transmit_USART(data[i]);
 818:	f6 01       	movw	r30, r12
 81a:	81 91       	ld	r24, Z+
 81c:	6f 01       	movw	r12, r30
 81e:	0e 94 7b 02 	call	0x4f6	; 0x4f6 <transmit_USART>
				_delay_ms(5);
				//transmit_string_USART("Data = ");
				_delay_ms(5);
				//transmit_string_USART(data);
				data[34] = 'm';
				for(int i =0; i<35; i++){
 822:	ca 14       	cp	r12, r10
 824:	db 04       	cpc	r13, r11
 826:	c1 f7       	brne	.-16     	; 0x818 <CC_Receive+0x168>
 828:	83 ec       	ldi	r24, 0xC3	; 195
 82a:	99 e0       	ldi	r25, 0x09	; 9
 82c:	01 97       	sbiw	r24, 0x01	; 1
 82e:	f1 f7       	brne	.-4      	; 0x82c <CC_Receive+0x17c>
 830:	00 c0       	rjmp	.+0      	; 0x832 <CC_Receive+0x182>
 832:	00 00       	nop
					transmit_USART(data[i]);
				}
				_delay_ms(5);
				transmit_USART("\n");
 834:	88 2d       	mov	r24, r8
 836:	0e 94 7b 02 	call	0x4f6	; 0x4f6 <transmit_USART>
					transmit_string_USART("\r\n");
					//ccxxx0_ReadBurst(CCxxx0_RXFIFO, temp, pkt_length-8);
					//transmit_string_USART((char *)temp);
				}
			}*/
			ccxxx0_Strobe(CCxxx0_SIDLE);//Exit RX / TX, turn off frequency synthesizer and exit Wake-On-Radio mode if applicable
 83a:	86 e3       	ldi	r24, 0x36	; 54
 83c:	0e 94 e2 01 	call	0x3c4	; 0x3c4 <ccxxx0_Strobe>
			ccxxx0_WriteBurst(CCxxx0_PATABLE, &paTable[0], 1); // max power
 840:	41 e0       	ldi	r20, 0x01	; 1
 842:	50 e0       	ldi	r21, 0x00	; 0
 844:	60 e0       	ldi	r22, 0x00	; 0
 846:	70 e2       	ldi	r23, 0x20	; 32
 848:	8e e3       	ldi	r24, 0x3E	; 62
 84a:	0e 94 24 02 	call	0x448	; 0x448 <ccxxx0_WriteBurst>
 84e:	e3 ef       	ldi	r30, 0xF3	; 243
 850:	f1 e0       	ldi	r31, 0x01	; 1
 852:	31 97       	sbiw	r30, 0x01	; 1
 854:	f1 f7       	brne	.-4      	; 0x852 <CC_Receive+0x1a2>
 856:	00 c0       	rjmp	.+0      	; 0x858 <CC_Receive+0x1a8>
 858:	00 00       	nop
			_delay_ms(1);
			ccxxx0_Strobe(CCxxx0_SFRX); // flush rx buf
 85a:	8a e3       	ldi	r24, 0x3A	; 58
 85c:	0e 94 e2 01 	call	0x3c4	; 0x3c4 <ccxxx0_Strobe>
			ccxxx0_Strobe(CCxxx0_SRX); // goto rx mode
 860:	84 e3       	ldi	r24, 0x34	; 52
 862:	0e 94 e2 01 	call	0x3c4	; 0x3c4 <ccxxx0_Strobe>
 866:	5f cf       	rjmp	.-322    	; 0x726 <CC_Receive+0x76>

00000868 <main>:

	/*uint8_t rssi_dec;
	int16_t rssi_dBm;
	uint8_t rssi_offset = 74; // CC1101 at 433 MHz*/

	cli(); 							//Clears the global interrupts
 868:	f8 94       	cli
	SPI_Master_Init();
 86a:	0e 94 74 01 	call	0x2e8	; 0x2e8 <SPI_Master_Init>
	sei();
 86e:	78 94       	sei
 870:	2f ef       	ldi	r18, 0xFF	; 255
 872:	84 e3       	ldi	r24, 0x34	; 52
 874:	9c e0       	ldi	r25, 0x0C	; 12
 876:	21 50       	subi	r18, 0x01	; 1
 878:	80 40       	sbci	r24, 0x00	; 0
 87a:	90 40       	sbci	r25, 0x00	; 0
 87c:	e1 f7       	brne	.-8      	; 0x876 <main+0xe>
 87e:	00 c0       	rjmp	.+0      	; 0x880 <main+0x18>
 880:	00 00       	nop

	//transmit_string_USART((unsigned char *)"cc1101_PowerOnReset\r\n");
	_delay_ms(2000);
	ccxxx0_PowerOnReset();
 882:	0e 94 50 02 	call	0x4a0	; 0x4a0 <ccxxx0_PowerOnReset>
	//PORTC=0x01;
//	_delay_ms(1000);
	//transmit_string_USART((unsigned char *)"cc1101_Setup\r\n");
	ccxxx0_Setup(); //&rfSettings);
 886:	0e 94 03 03 	call	0x606	; 0x606 <ccxxx0_Setup>
	//transmit_string_USART((unsigned char *)"Started\r\n");
	unsigned char part = 'b';
	part = ccxxx0_Read(CCxxx0_VERSION);
 88a:	81 ef       	ldi	r24, 0xF1	; 241
 88c:	0e 94 a5 01 	call	0x34a	; 0x34a <ccxxx0_Read>
 890:	2f ef       	ldi	r18, 0xFF	; 255
 892:	88 e0       	ldi	r24, 0x08	; 8
 894:	9d e3       	ldi	r25, 0x3D	; 61
 896:	21 50       	subi	r18, 0x01	; 1
 898:	80 40       	sbci	r24, 0x00	; 0
 89a:	90 40       	sbci	r25, 0x00	; 0
 89c:	e1 f7       	brne	.-8      	; 0x896 <main+0x2e>
 89e:	00 c0       	rjmp	.+0      	; 0x8a0 <main+0x38>
 8a0:	00 00       	nop
		//ccxxx0_Write(CCxxx0_IOCFG0, 0x2F);
	for (int i=0;i<5;i++)
		current_status[i]=address[i];
		//transmit_string_USART(address);
		_delay_ms(10000);
		transmit_string_USART("Started \n");
 8a2:	83 e2       	ldi	r24, 0x23	; 35
 8a4:	90 e2       	ldi	r25, 0x20	; 32
 8a6:	0e 94 bc 02 	call	0x578	; 0x578 <transmit_string_USART>

		while(1)
		{
			//toggle_ind=PINC;
			CC_Receive();
 8aa:	0e 94 58 03 	call	0x6b0	; 0x6b0 <CC_Receive>

000008ae <strcpy>:
 8ae:	fb 01       	movw	r30, r22
 8b0:	dc 01       	movw	r26, r24
 8b2:	01 90       	ld	r0, Z+
 8b4:	0d 92       	st	X+, r0
 8b6:	00 20       	and	r0, r0
 8b8:	e1 f7       	brne	.-8      	; 0x8b2 <strcpy+0x4>
 8ba:	08 95       	ret

000008bc <_exit>:
 8bc:	f8 94       	cli

000008be <__stop_program>:
 8be:	ff cf       	rjmp	.-2      	; 0x8be <__stop_program>
