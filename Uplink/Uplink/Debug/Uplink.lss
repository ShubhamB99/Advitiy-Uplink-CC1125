
Uplink.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000094c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000042  00802000  0000094c  000009e0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000016d  00802042  00802042  00000a22  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000a22  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000a54  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000130  00000000  00000000  00000a94  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000056fb  00000000  00000000  00000bc4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000035c4  00000000  00000000  000062bf  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000134b  00000000  00000000  00009883  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000344  00000000  00000000  0000abd0  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00003000  00000000  00000000  0000af14  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001ac2  00000000  00000000  0000df14  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000150  00000000  00000000  0000f9d6  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__ctors_end>
   4:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
   8:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
   c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  10:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  14:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  18:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  1c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  20:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  24:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  28:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  2c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  30:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  34:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  38:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  3c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  40:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  44:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  48:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  4c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  50:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  54:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  58:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  5c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  60:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  64:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  68:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  6c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  70:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  74:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  78:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  7c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  80:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  84:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  88:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  8c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  90:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  94:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  98:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  9c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  a0:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  a4:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  a8:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  ac:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  b0:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  b4:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  b8:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  bc:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  c0:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  c4:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  c8:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  cc:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  d0:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  d4:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  d8:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  dc:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  e0:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  e4:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  e8:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  ec:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  f0:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  f4:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  f8:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
  fc:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 100:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 104:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 108:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 10c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 110:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 114:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 118:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 11c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 120:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 124:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 128:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 12c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 130:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 134:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 138:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 13c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 140:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 144:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 148:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 14c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 150:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 154:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 158:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 15c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 160:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 164:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 168:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 16c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 170:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 174:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 178:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 17c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 180:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 184:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 188:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 18c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 190:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 194:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 198:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 19c:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1a0:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1a4:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1a8:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1ac:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1b0:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1b4:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1b8:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1bc:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1c0:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1c4:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1c8:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1cc:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1d0:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1d4:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1d8:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1dc:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1e0:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1e4:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1e8:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1ec:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1f0:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1f4:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>
 1f8:	0c 94 1f 01 	jmp	0x23e	; 0x23e <__bad_interrupt>

000001fc <__ctors_end>:
 1fc:	11 24       	eor	r1, r1
 1fe:	1f be       	out	0x3f, r1	; 63
 200:	cf ef       	ldi	r28, 0xFF	; 255
 202:	cd bf       	out	0x3d, r28	; 61
 204:	df e3       	ldi	r29, 0x3F	; 63
 206:	de bf       	out	0x3e, r29	; 62
 208:	00 e0       	ldi	r16, 0x00	; 0
 20a:	0c bf       	out	0x3c, r16	; 60

0000020c <__do_copy_data>:
 20c:	10 e2       	ldi	r17, 0x20	; 32
 20e:	a0 e0       	ldi	r26, 0x00	; 0
 210:	b0 e2       	ldi	r27, 0x20	; 32
 212:	ec e4       	ldi	r30, 0x4C	; 76
 214:	f9 e0       	ldi	r31, 0x09	; 9
 216:	00 e0       	ldi	r16, 0x00	; 0
 218:	0b bf       	out	0x3b, r16	; 59
 21a:	02 c0       	rjmp	.+4      	; 0x220 <__do_copy_data+0x14>
 21c:	07 90       	elpm	r0, Z+
 21e:	0d 92       	st	X+, r0
 220:	a2 34       	cpi	r26, 0x42	; 66
 222:	b1 07       	cpc	r27, r17
 224:	d9 f7       	brne	.-10     	; 0x21c <__do_copy_data+0x10>

00000226 <__do_clear_bss>:
 226:	21 e2       	ldi	r18, 0x21	; 33
 228:	a2 e4       	ldi	r26, 0x42	; 66
 22a:	b0 e2       	ldi	r27, 0x20	; 32
 22c:	01 c0       	rjmp	.+2      	; 0x230 <.do_clear_bss_start>

0000022e <.do_clear_bss_loop>:
 22e:	1d 92       	st	X+, r1

00000230 <.do_clear_bss_start>:
 230:	af 3a       	cpi	r26, 0xAF	; 175
 232:	b2 07       	cpc	r27, r18
 234:	e1 f7       	brne	.-8      	; 0x22e <.do_clear_bss_loop>
 236:	0e 94 78 04 	call	0x8f0	; 0x8f0 <main>
 23a:	0c 94 a4 04 	jmp	0x948	; 0x948 <_exit>

0000023e <__bad_interrupt>:
 23e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000242 <crc16>:
	spi->dataPacket->bytesTransceived = bytesTransceived;
	spi->dataPacket->complete = true;

	/* Report success. */
	return true;
}
 242:	7f ef       	ldi	r23, 0xFF	; 255
 244:	76 0f       	add	r23, r22
 246:	66 23       	and	r22, r22
 248:	29 f1       	breq	.+74     	; 0x294 <crc16+0x52>
 24a:	e8 2f       	mov	r30, r24
 24c:	f9 2f       	mov	r31, r25
 24e:	4f ef       	ldi	r20, 0xFF	; 255
 250:	5f ef       	ldi	r21, 0xFF	; 255
 252:	21 91       	ld	r18, Z+
 254:	25 27       	eor	r18, r21
 256:	32 2f       	mov	r19, r18
 258:	32 95       	swap	r19
 25a:	3f 70       	andi	r19, 0x0F	; 15
 25c:	92 2f       	mov	r25, r18
 25e:	93 27       	eor	r25, r19
 260:	29 2f       	mov	r18, r25
 262:	30 e0       	ldi	r19, 0x00	; 0
 264:	54 2f       	mov	r21, r20
 266:	44 27       	eor	r20, r20
 268:	42 27       	eor	r20, r18
 26a:	53 27       	eor	r21, r19
 26c:	c9 01       	movw	r24, r18
 26e:	98 2f       	mov	r25, r24
 270:	88 27       	eor	r24, r24
 272:	92 95       	swap	r25
 274:	90 7f       	andi	r25, 0xF0	; 240
 276:	48 27       	eor	r20, r24
 278:	59 27       	eor	r21, r25
 27a:	22 0f       	add	r18, r18
 27c:	33 1f       	adc	r19, r19
 27e:	22 95       	swap	r18
 280:	32 95       	swap	r19
 282:	30 7f       	andi	r19, 0xF0	; 240
 284:	32 27       	eor	r19, r18
 286:	20 7f       	andi	r18, 0xF0	; 240
 288:	32 27       	eor	r19, r18
 28a:	42 27       	eor	r20, r18
 28c:	53 27       	eor	r21, r19
 28e:	71 50       	subi	r23, 0x01	; 1
 290:	00 f7       	brcc	.-64     	; 0x252 <crc16+0x10>
 292:	02 c0       	rjmp	.+4      	; 0x298 <crc16+0x56>
 294:	4f ef       	ldi	r20, 0xFF	; 255
 296:	5f ef       	ldi	r21, 0xFF	; 255
 298:	ca 01       	movw	r24, r20
 29a:	08 95       	ret

0000029c <USART_TXBuffer_FreeSpace>:
 29c:	fc 01       	movw	r30, r24
 29e:	95 85       	ldd	r25, Z+13	; 0x0d
 2a0:	26 85       	ldd	r18, Z+14	; 0x0e
 2a2:	9f 5f       	subi	r25, 0xFF	; 255
 2a4:	93 70       	andi	r25, 0x03	; 3
 2a6:	81 e0       	ldi	r24, 0x01	; 1
 2a8:	92 13       	cpse	r25, r18
 2aa:	01 c0       	rjmp	.+2      	; 0x2ae <USART_TXBuffer_FreeSpace+0x12>
 2ac:	80 e0       	ldi	r24, 0x00	; 0
 2ae:	08 95       	ret

000002b0 <USART_TXBuffer_PutByte>:
 2b0:	1f 93       	push	r17
 2b2:	cf 93       	push	r28
 2b4:	df 93       	push	r29
 2b6:	ec 01       	movw	r28, r24
 2b8:	16 2f       	mov	r17, r22
 2ba:	0e 94 4e 01 	call	0x29c	; 0x29c <USART_TXBuffer_FreeSpace>
 2be:	88 23       	and	r24, r24
 2c0:	79 f0       	breq	.+30     	; 0x2e0 <USART_TXBuffer_PutByte+0x30>
 2c2:	9d 85       	ldd	r25, Y+13	; 0x0d
 2c4:	fe 01       	movw	r30, r28
 2c6:	e9 0f       	add	r30, r25
 2c8:	f1 1d       	adc	r31, r1
 2ca:	17 83       	std	Z+7, r17	; 0x07
 2cc:	9f 5f       	subi	r25, 0xFF	; 255
 2ce:	93 70       	andi	r25, 0x03	; 3
 2d0:	9d 87       	std	Y+13, r25	; 0x0d
 2d2:	e8 81       	ld	r30, Y
 2d4:	f9 81       	ldd	r31, Y+1	; 0x01
 2d6:	93 81       	ldd	r25, Z+3	; 0x03
 2d8:	9c 7f       	andi	r25, 0xFC	; 252
 2da:	2a 81       	ldd	r18, Y+2	; 0x02
 2dc:	92 2b       	or	r25, r18
 2de:	93 83       	std	Z+3, r25	; 0x03
 2e0:	df 91       	pop	r29
 2e2:	cf 91       	pop	r28
 2e4:	1f 91       	pop	r17
 2e6:	08 95       	ret

000002e8 <SPI_Master_Init>:

}
*/

void SPI_Master_Init()	
{
 2e8:	cf 93       	push	r28
 2ea:	df 93       	push	r29
	// ** Do initialisation to 2 ports for UART **
	
	//SPI Register Configuration
	PORTE.DIRSET = PIN4_bm;																							//Set SS as output
 2ec:	e0 e8       	ldi	r30, 0x80	; 128
 2ee:	f6 e0       	ldi	r31, 0x06	; 6
 2f0:	20 e1       	ldi	r18, 0x10	; 16
 2f2:	21 83       	std	Z+1, r18	; 0x01
	PORTE.DIRSET = PIN5_bm;																							//MOSI as output
 2f4:	80 e2       	ldi	r24, 0x20	; 32
 2f6:	81 83       	std	Z+1, r24	; 0x01
	PORTE.DIRSET = PIN7_bm;																							//SCK as output
 2f8:	90 e8       	ldi	r25, 0x80	; 128
 2fa:	91 83       	std	Z+1, r25	; 0x01
	PORTE.PIN4CTRL = PORT_OPC_WIREDANDPULL_gc;																		//Set PullUp at SS 
 2fc:	38 e3       	ldi	r19, 0x38	; 56
 2fe:	34 8b       	std	Z+20, r19	; 0x14
	// We can't leave PIN4 to a floating state of 0 or 3.3V when in idle state, so we set it to always high being connected to VCC until we explicitly make it low
	PORTE.OUTSET = PIN4_bm;																							//Set SS high for no Slave
 300:	25 83       	std	Z+5, r18	; 0x05
                    SPI_MODE_t mode,
                    SPI_INTLVL_t intLevel,
                    bool clk2x,
                    SPI_PRESCALER_t clockDivision)
{
	spi->module         = module;
 302:	ac e0       	ldi	r26, 0x0C	; 12
 304:	b1 e2       	ldi	r27, 0x21	; 33
 306:	c0 ec       	ldi	r28, 0xC0	; 192
 308:	d8 e0       	ldi	r29, 0x08	; 8
 30a:	cd 93       	st	X+, r28
 30c:	dc 93       	st	X, r29
 30e:	11 97       	sbiw	r26, 0x01	; 1
	spi->port           = port;
 310:	12 96       	adiw	r26, 0x02	; 2
 312:	ed 93       	st	X+, r30
 314:	fc 93       	st	X, r31
 316:	13 97       	sbiw	r26, 0x03	; 3
	spi->interrupted    = false;
 318:	14 96       	adiw	r26, 0x04	; 4
 31a:	1c 92       	st	X, r1
 31c:	14 97       	sbiw	r26, 0x04	; 4

	spi->module->CTRL   = clockDivision |                  /* SPI prescaler. */
 31e:	28 ed       	ldi	r18, 0xD8	; 216
 320:	28 83       	st	Y, r18
	                      (lsbFirst ? SPI_DORD_bm  : 0) |  /* Data order. */
	                      SPI_MASTER_bm |                  /* SPI master. */
	                      mode;                            /* SPI mode. */

	/* Interrupt level. */
	spi->module->INTCTRL = intLevel;
 322:	cd 91       	ld	r28, X+
 324:	dc 91       	ld	r29, X
 326:	11 97       	sbiw	r26, 0x01	; 1
 328:	19 82       	std	Y+1, r1	; 0x01

	/* No assigned data packet. */
	spi->dataPacket = NULL;
 32a:	15 96       	adiw	r26, 0x05	; 5
 32c:	1d 92       	st	X+, r1
 32e:	1c 92       	st	X, r1
 330:	16 97       	sbiw	r26, 0x06	; 6

 	/* MOSI and SCK as output. */
	spi->port->DIRSET  = SPI_MOSI_bm | SPI_SCK_bm;
 332:	12 96       	adiw	r26, 0x02	; 2
 334:	0d 90       	ld	r0, X+
 336:	bc 91       	ld	r27, X
 338:	a0 2d       	mov	r26, r0
 33a:	20 ea       	ldi	r18, 0xA0	; 160
 33c:	11 96       	adiw	r26, 0x01	; 1
 33e:	2c 93       	st	X, r18
	SPI_MasterInit(&spiMasterC,&SPIC,&PORTE,false,SPI_MODE_2_gc,SPI_INTLVL_OFF_gc,true,SPI_PRESCALER_DIV4_gc);		//Initialize device as master (Mode 2, MSB first, 2X speed, prescaler 4)
	// Use Mode 0, Mode 2 refers '10' in binary, false value for first 4, true for next 4, use eg. DIV16 for fosc/16 
	PORTE.OUTSET = PIN7_bm;
 340:	95 83       	std	Z+5, r25	; 0x05
	PORTE.OUTCLR = PIN5_bm;
 342:	86 83       	std	Z+6, r24	; 0x06
}
 344:	df 91       	pop	r29
 346:	cf 91       	pop	r28
 348:	08 95       	ret

0000034a <ccxxx0_Read>:


unsigned char ccxxx0_Read(unsigned char addr)			// - DONE
{
	unsigned char x; // The variable where the read Byte is stored
	PORTE.OUTCLR = PIN4_bm; // make the SS pin low to start the communication
 34a:	90 e1       	ldi	r25, 0x10	; 16
 34c:	90 93 86 06 	sts	0x0686, r25	; 0x800686 <__TEXT_REGION_LENGTH__+0x700686>

	while(PORTE.IN & PIN6_bm);
 350:	e0 e8       	ldi	r30, 0x80	; 128
 352:	f6 e0       	ldi	r31, 0x06	; 6
 354:	90 85       	ldd	r25, Z+8	; 0x08
 356:	96 fd       	sbrc	r25, 6
 358:	fd cf       	rjmp	.-6      	; 0x354 <ccxxx0_Read+0xa>

	SPIC_DATA = (addr | 0x80); // Header byte R/~W bit - 1 Burst bit - 0
 35a:	80 68       	ori	r24, 0x80	; 128
 35c:	80 93 c3 08 	sts	0x08C3, r24	; 0x8008c3 <__TEXT_REGION_LENGTH__+0x7008c3>
	while(!(SPIC_STATUS & PIN7_bm)); // Wait for transmission to be completed
 360:	e2 ec       	ldi	r30, 0xC2	; 194
 362:	f8 e0       	ldi	r31, 0x08	; 8
 364:	80 81       	ld	r24, Z
 366:	88 23       	and	r24, r24
 368:	ec f7       	brge	.-6      	; 0x364 <ccxxx0_Read+0x1a>
	x = SPIC_DATA; // flush SPDR
 36a:	e3 ec       	ldi	r30, 0xC3	; 195
 36c:	f8 e0       	ldi	r31, 0x08	; 8
 36e:	80 81       	ld	r24, Z

// Receiving the byte at addr
	SPIC_DATA = 0;
 370:	10 82       	st	Z, r1
	while(!(SPIC_STATUS & PIN7_bm));
 372:	e2 ec       	ldi	r30, 0xC2	; 194
 374:	f8 e0       	ldi	r31, 0x08	; 8
 376:	80 81       	ld	r24, Z
 378:	88 23       	and	r24, r24
 37a:	ec f7       	brge	.-6      	; 0x376 <ccxxx0_Read+0x2c>
	x = SPIC_DATA; //// flush SPDR
 37c:	80 91 c3 08 	lds	r24, 0x08C3	; 0x8008c3 <__TEXT_REGION_LENGTH__+0x7008c3>

	PORTE.OUTSET = PIN4_bm; // Make SS high to stop communication
 380:	90 e1       	ldi	r25, 0x10	; 16
 382:	90 93 85 06 	sts	0x0685, r25	; 0x800685 <__TEXT_REGION_LENGTH__+0x700685>

	return x;
}
 386:	08 95       	ret

00000388 <ccxxx0_Write>:

unsigned char ccxxx0_Write(unsigned char addr, unsigned char dat)			// - DONE
{
	unsigned char x;
	PORTE.OUTCLR = PIN4_bm;	 // make the SS pin low to start the communication
 388:	90 e1       	ldi	r25, 0x10	; 16
 38a:	90 93 86 06 	sts	0x0686, r25	; 0x800686 <__TEXT_REGION_LENGTH__+0x700686>

	while(PORTE.IN & PIN6_bm);
 38e:	e0 e8       	ldi	r30, 0x80	; 128
 390:	f6 e0       	ldi	r31, 0x06	; 6
 392:	90 85       	ldd	r25, Z+8	; 0x08
 394:	96 fd       	sbrc	r25, 6
 396:	fd cf       	rjmp	.-6      	; 0x392 <ccxxx0_Write+0xa>

	SPIC_DATA = addr; // Header Byte R/~W bit - 0 Burst bit - 0
 398:	80 93 c3 08 	sts	0x08C3, r24	; 0x8008c3 <__TEXT_REGION_LENGTH__+0x7008c3>
	while(!(SPIC_STATUS & PIN7_bm));
 39c:	e2 ec       	ldi	r30, 0xC2	; 194
 39e:	f8 e0       	ldi	r31, 0x08	; 8
 3a0:	80 81       	ld	r24, Z
 3a2:	88 23       	and	r24, r24
 3a4:	ec f7       	brge	.-6      	; 0x3a0 <ccxxx0_Write+0x18>
	x = SPIC_DATA;// flush SPDR
 3a6:	e3 ec       	ldi	r30, 0xC3	; 195
 3a8:	f8 e0       	ldi	r31, 0x08	; 8
 3aa:	80 81       	ld	r24, Z

	SPIC_DATA = dat; // data to be written at addr
 3ac:	60 83       	st	Z, r22
	while(!(SPIC_STATUS & PIN7_bm));
 3ae:	e2 ec       	ldi	r30, 0xC2	; 194
 3b0:	f8 e0       	ldi	r31, 0x08	; 8
 3b2:	80 81       	ld	r24, Z
 3b4:	88 23       	and	r24, r24
 3b6:	ec f7       	brge	.-6      	; 0x3b2 <ccxxx0_Write+0x2a>
	x = SPIC_DATA; // get data from SPDR
 3b8:	80 91 c3 08 	lds	r24, 0x08C3	; 0x8008c3 <__TEXT_REGION_LENGTH__+0x7008c3>

	PORTE.OUTSET = PIN4_bm; // Make SS high to stop communication
 3bc:	90 e1       	ldi	r25, 0x10	; 16
 3be:	90 93 85 06 	sts	0x0685, r25	; 0x800685 <__TEXT_REGION_LENGTH__+0x700685>

	return x; // The Chip Status Byte
}
 3c2:	08 95       	ret

000003c4 <ccxxx0_Strobe>:

unsigned char ccxxx0_Strobe(unsigned char addr)		// - DONE
{
    unsigned char x;
	PORTE.OUTCLR = PIN4_bm;			// make the SS pin low to start the communication
 3c4:	90 e1       	ldi	r25, 0x10	; 16
 3c6:	90 93 86 06 	sts	0x0686, r25	; 0x800686 <__TEXT_REGION_LENGTH__+0x700686>

	while(PORTE.IN & PIN6_bm);
 3ca:	e0 e8       	ldi	r30, 0x80	; 128
 3cc:	f6 e0       	ldi	r31, 0x06	; 6
 3ce:	90 85       	ldd	r25, Z+8	; 0x08
 3d0:	96 fd       	sbrc	r25, 6
 3d2:	fd cf       	rjmp	.-6      	; 0x3ce <ccxxx0_Strobe+0xa>

    SPIC_DATA = addr;				// The address of the Strobe Command
 3d4:	80 93 c3 08 	sts	0x08C3, r24	; 0x8008c3 <__TEXT_REGION_LENGTH__+0x7008c3>
	while(!(SPIC_STATUS & PIN7_bm));
 3d8:	e2 ec       	ldi	r30, 0xC2	; 194
 3da:	f8 e0       	ldi	r31, 0x08	; 8
 3dc:	80 81       	ld	r24, Z
 3de:	88 23       	and	r24, r24
 3e0:	ec f7       	brge	.-6      	; 0x3dc <ccxxx0_Strobe+0x18>
    x = SPIC_DATA;					// flush SPDR the Status Byte
 3e2:	80 91 c3 08 	lds	r24, 0x08C3	; 0x8008c3 <__TEXT_REGION_LENGTH__+0x7008c3>

    PORTE.OUTSET = PIN4_bm;			// Make SS high to stop communication
 3e6:	90 e1       	ldi	r25, 0x10	; 16
 3e8:	90 93 85 06 	sts	0x0685, r25	; 0x800685 <__TEXT_REGION_LENGTH__+0x700685>

    return x;
}
 3ec:	08 95       	ret

000003ee <ccxxx0_ReadBurst>:

void ccxxx0_ReadBurst(unsigned char addr, unsigned char* dataPtr, unsigned int dataCount)		// - DONE
{
 3ee:	cf 93       	push	r28
 3f0:	df 93       	push	r29
	unsigned char x;

	PORTE.OUTCLR = PIN4_bm; // make the SS pin low to start the communication
 3f2:	90 e1       	ldi	r25, 0x10	; 16
 3f4:	90 93 86 06 	sts	0x0686, r25	; 0x800686 <__TEXT_REGION_LENGTH__+0x700686>

	while(PORTE.IN & PIN6_bm);
 3f8:	e0 e8       	ldi	r30, 0x80	; 128
 3fa:	f6 e0       	ldi	r31, 0x06	; 6
 3fc:	90 85       	ldd	r25, Z+8	; 0x08
 3fe:	96 fd       	sbrc	r25, 6
 400:	fd cf       	rjmp	.-6      	; 0x3fc <ccxxx0_ReadBurst+0xe>

    SPIC_DATA = (addr | 0xc0); // Header Byte R/~W bit - 1 Burst bit - 1
 402:	80 6c       	ori	r24, 0xC0	; 192
 404:	80 93 c3 08 	sts	0x08C3, r24	; 0x8008c3 <__TEXT_REGION_LENGTH__+0x7008c3>
	while(!(SPIC_STATUS & PIN7_bm));
 408:	e2 ec       	ldi	r30, 0xC2	; 194
 40a:	f8 e0       	ldi	r31, 0x08	; 8
 40c:	80 81       	ld	r24, Z
 40e:	88 23       	and	r24, r24
 410:	ec f7       	brge	.-6      	; 0x40c <__LOCK_REGION_LENGTH__+0xc>
	x = SPIC_DATA;// flush SPDR
 412:	80 91 c3 08 	lds	r24, 0x08C3	; 0x8008c3 <__TEXT_REGION_LENGTH__+0x7008c3>

	while(dataCount) { // Loop that stops communication when desired number of bytes are read
 416:	41 15       	cp	r20, r1
 418:	51 05       	cpc	r21, r1
 41a:	81 f0       	breq	.+32     	; 0x43c <__LOCK_REGION_LENGTH__+0x3c>
 41c:	db 01       	movw	r26, r22
 41e:	46 0f       	add	r20, r22
 420:	57 1f       	adc	r21, r23
	    SPIC_DATA = 0;
 422:	c3 ec       	ldi	r28, 0xC3	; 195
 424:	d8 e0       	ldi	r29, 0x08	; 8
		while(!(SPIC_STATUS & PIN7_bm));
 426:	e2 ec       	ldi	r30, 0xC2	; 194
 428:	f8 e0       	ldi	r31, 0x08	; 8
    SPIC_DATA = (addr | 0xc0); // Header Byte R/~W bit - 1 Burst bit - 1
	while(!(SPIC_STATUS & PIN7_bm));
	x = SPIC_DATA;// flush SPDR

	while(dataCount) { // Loop that stops communication when desired number of bytes are read
	    SPIC_DATA = 0;
 42a:	18 82       	st	Y, r1
		while(!(SPIC_STATUS & PIN7_bm));
 42c:	80 81       	ld	r24, Z
 42e:	88 23       	and	r24, r24
 430:	ec f7       	brge	.-6      	; 0x42c <__LOCK_REGION_LENGTH__+0x2c>

	    *dataPtr++ = SPIC_DATA; // get data from SPDR, *dataPtr++ points the next element
 432:	88 81       	ld	r24, Y
 434:	8d 93       	st	X+, r24

    SPIC_DATA = (addr | 0xc0); // Header Byte R/~W bit - 1 Burst bit - 1
	while(!(SPIC_STATUS & PIN7_bm));
	x = SPIC_DATA;// flush SPDR

	while(dataCount) { // Loop that stops communication when desired number of bytes are read
 436:	a4 17       	cp	r26, r20
 438:	b5 07       	cpc	r27, r21
 43a:	b9 f7       	brne	.-18     	; 0x42a <__LOCK_REGION_LENGTH__+0x2a>

	    *dataPtr++ = SPIC_DATA; // get data from SPDR, *dataPtr++ points the next element
		dataCount--;
	}

    PORTE.OUTSET = PIN4_bm; // Make SS high to stop communication
 43c:	80 e1       	ldi	r24, 0x10	; 16
 43e:	80 93 85 06 	sts	0x0685, r24	; 0x800685 <__TEXT_REGION_LENGTH__+0x700685>
}
 442:	df 91       	pop	r29
 444:	cf 91       	pop	r28
 446:	08 95       	ret

00000448 <ccxxx0_WriteBurst>:

void ccxxx0_WriteBurst(unsigned char addr, unsigned char* dataPtr, unsigned int dataCount)			// - DONE
{
 448:	cf 93       	push	r28
 44a:	df 93       	push	r29
	unsigned char x;

	PORTE.OUTCLR = PIN4_bm; // make the SS pin low to start the communication
 44c:	90 e1       	ldi	r25, 0x10	; 16
 44e:	90 93 86 06 	sts	0x0686, r25	; 0x800686 <__TEXT_REGION_LENGTH__+0x700686>

	while(PORTE.IN & PIN6_bm);
 452:	e0 e8       	ldi	r30, 0x80	; 128
 454:	f6 e0       	ldi	r31, 0x06	; 6
 456:	90 85       	ldd	r25, Z+8	; 0x08
 458:	96 fd       	sbrc	r25, 6
 45a:	fd cf       	rjmp	.-6      	; 0x456 <ccxxx0_WriteBurst+0xe>

    SPIC_DATA = addr | 0x40; // Header Byte R/~W bit - 0 Burst bit - 1
 45c:	80 64       	ori	r24, 0x40	; 64
 45e:	80 93 c3 08 	sts	0x08C3, r24	; 0x8008c3 <__TEXT_REGION_LENGTH__+0x7008c3>
	while(!(SPIC_STATUS & PIN7_bm));
 462:	e2 ec       	ldi	r30, 0xC2	; 194
 464:	f8 e0       	ldi	r31, 0x08	; 8
 466:	80 81       	ld	r24, Z
 468:	88 23       	and	r24, r24
 46a:	ec f7       	brge	.-6      	; 0x466 <ccxxx0_WriteBurst+0x1e>
	x = SPIC_DATA; // flush SPDR
 46c:	80 91 c3 08 	lds	r24, 0x08C3	; 0x8008c3 <__TEXT_REGION_LENGTH__+0x7008c3>

	while(dataCount) { // Loop that stops communication after desired number of writing cycles
 470:	41 15       	cp	r20, r1
 472:	51 05       	cpc	r21, r1
 474:	79 f0       	breq	.+30     	; 0x494 <ccxxx0_WriteBurst+0x4c>
 476:	db 01       	movw	r26, r22
 478:	46 0f       	add	r20, r22
 47a:	57 1f       	adc	r21, r23
	    SPIC_DATA = *dataPtr++;
 47c:	c3 ec       	ldi	r28, 0xC3	; 195
 47e:	d8 e0       	ldi	r29, 0x08	; 8
		while(!(SPIC_STATUS & PIN7_bm));
 480:	e2 ec       	ldi	r30, 0xC2	; 194
 482:	f8 e0       	ldi	r31, 0x08	; 8
    SPIC_DATA = addr | 0x40; // Header Byte R/~W bit - 0 Burst bit - 1
	while(!(SPIC_STATUS & PIN7_bm));
	x = SPIC_DATA; // flush SPDR

	while(dataCount) { // Loop that stops communication after desired number of writing cycles
	    SPIC_DATA = *dataPtr++;
 484:	8d 91       	ld	r24, X+
 486:	88 83       	st	Y, r24
		while(!(SPIC_STATUS & PIN7_bm));
 488:	80 81       	ld	r24, Z
 48a:	88 23       	and	r24, r24
 48c:	ec f7       	brge	.-6      	; 0x488 <ccxxx0_WriteBurst+0x40>

    SPIC_DATA = addr | 0x40; // Header Byte R/~W bit - 0 Burst bit - 1
	while(!(SPIC_STATUS & PIN7_bm));
	x = SPIC_DATA; // flush SPDR

	while(dataCount) { // Loop that stops communication after desired number of writing cycles
 48e:	a4 17       	cp	r26, r20
 490:	b5 07       	cpc	r27, r21
 492:	c1 f7       	brne	.-16     	; 0x484 <ccxxx0_WriteBurst+0x3c>
		while(!(SPIC_STATUS & PIN7_bm));

		dataCount--;
	}

    PORTE.OUTSET = PIN4_bm; // Make SS high to stop communication
 494:	80 e1       	ldi	r24, 0x10	; 16
 496:	80 93 85 06 	sts	0x0685, r24	; 0x800685 <__TEXT_REGION_LENGTH__+0x700685>
}
 49a:	df 91       	pop	r29
 49c:	cf 91       	pop	r28
 49e:	08 95       	ret

000004a0 <ccxxx0_PowerOnReset>:

void ccxxx0_PowerOnReset() // Manual Reset		// - DONE
{
	unsigned char x;
	//datasheet cc1101 pg on.51 Manual Reset
    PORTE.OUTSET = PIN4_bm; // Make SS high
 4a0:	e0 e8       	ldi	r30, 0x80	; 128
 4a2:	f6 e0       	ldi	r31, 0x06	; 6
 4a4:	80 e1       	ldi	r24, 0x10	; 16
 4a6:	85 83       	std	Z+5, r24	; 0x05
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 4a8:	00 c0       	rjmp	.+0      	; 0x4aa <ccxxx0_PowerOnReset+0xa>
	_delay_us(1);								// ** Check how much delay we need in ATXMega corresponding to these functions **
	PORTE.OUTCLR = PIN4_bm; // Make SS low
 4aa:	86 83       	std	Z+6, r24	; 0x06
 4ac:	00 c0       	rjmp	.+0      	; 0x4ae <ccxxx0_PowerOnReset+0xe>
	_delay_us(1);
    PORTE.OUTSET = PIN4_bm; // Make SS high for atleast 41 us
 4ae:	85 83       	std	Z+5, r24	; 0x05
 4b0:	9b e1       	ldi	r25, 0x1B	; 27
 4b2:	9a 95       	dec	r25
 4b4:	f1 f7       	brne	.-4      	; 0x4b2 <ccxxx0_PowerOnReset+0x12>
 4b6:	00 00       	nop
	_delay_us(41);

	PORTE.OUTCLR = PIN4_bm; // Make SS low
 4b8:	86 83       	std	Z+6, r24	; 0x06

	while(PORTE.IN & PIN6_bm); // wait for SO to go low
 4ba:	80 85       	ldd	r24, Z+8	; 0x08
 4bc:	86 fd       	sbrc	r24, 6
 4be:	fd cf       	rjmp	.-6      	; 0x4ba <ccxxx0_PowerOnReset+0x1a>
 4c0:	81 e2       	ldi	r24, 0x21	; 33
 4c2:	8a 95       	dec	r24
 4c4:	f1 f7       	brne	.-4      	; 0x4c2 <ccxxx0_PowerOnReset+0x22>
 4c6:	00 00       	nop

	_delay_us(50);

    SPIC_DATA = CCxxx0_SRES; // Isssue the SRES command strobe
 4c8:	80 e3       	ldi	r24, 0x30	; 48
 4ca:	80 93 c3 08 	sts	0x08C3, r24	; 0x8008c3 <__TEXT_REGION_LENGTH__+0x7008c3>
	while(!(SPIC_STATUS & PIN7_bm));
 4ce:	e2 ec       	ldi	r30, 0xC2	; 194
 4d0:	f8 e0       	ldi	r31, 0x08	; 8
 4d2:	80 81       	ld	r24, Z
 4d4:	88 23       	and	r24, r24
 4d6:	ec f7       	brge	.-6      	; 0x4d2 <ccxxx0_PowerOnReset+0x32>
	x = SPIC_DATA; // flush SPDR
 4d8:	80 91 c3 08 	lds	r24, 0x08C3	; 0x8008c3 <__TEXT_REGION_LENGTH__+0x7008c3>

	while(PORTE.IN & PIN6_bm); // When SO goes low again, reset is complete
 4dc:	e0 e8       	ldi	r30, 0x80	; 128
 4de:	f6 e0       	ldi	r31, 0x06	; 6
 4e0:	80 85       	ldd	r24, Z+8	; 0x08
 4e2:	86 fd       	sbrc	r24, 6
 4e4:	fd cf       	rjmp	.-6      	; 0x4e0 <ccxxx0_PowerOnReset+0x40>
 4e6:	91 e2       	ldi	r25, 0x21	; 33
 4e8:	9a 95       	dec	r25
 4ea:	f1 f7       	brne	.-4      	; 0x4e8 <ccxxx0_PowerOnReset+0x48>
 4ec:	00 00       	nop

// **THE CHIP IS IDLE STATE AFTER RESET**

	_delay_us(50);

    PORTE.OUTSET = PIN4_bm; // Make SS high
 4ee:	80 e1       	ldi	r24, 0x10	; 16
 4f0:	80 93 85 06 	sts	0x0685, r24	; 0x800685 <__TEXT_REGION_LENGTH__+0x700685>
 4f4:	08 95       	ret

000004f6 <transmit_USART>:
}

void transmit_USART(char data)
{
 4f6:	cf 93       	push	r28
 4f8:	df 93       	push	r29
	uint8_t i;
	PORTC.DIRSET   = PIN3_bm;
 4fa:	e0 e4       	ldi	r30, 0x40	; 64
 4fc:	f6 e0       	ldi	r31, 0x06	; 6
 4fe:	98 e0       	ldi	r25, 0x08	; 8
 500:	91 83       	std	Z+1, r25	; 0x01
	PORTC.DIRCLR   = PIN2_bm;
 502:	94 e0       	ldi	r25, 0x04	; 4
 504:	92 83       	std	Z+2, r25	; 0x02
 */
void USART_InterruptDriver_Initialize(USART_data_t * usart_data,
                                      USART_t * usart,
                                      USART_DREINTLVL_t dreIntLevel)
{
	usart_data->usart = usart;
 506:	ad ef       	ldi	r26, 0xFD	; 253
 508:	b0 e2       	ldi	r27, 0x20	; 32
 50a:	e0 ea       	ldi	r30, 0xA0	; 160
 50c:	f8 e0       	ldi	r31, 0x08	; 8
 50e:	ed 93       	st	X+, r30
 510:	fc 93       	st	X, r31
 512:	11 97       	sbiw	r26, 0x01	; 1
	usart_data->dreIntLevel = dreIntLevel;
 514:	91 e0       	ldi	r25, 0x01	; 1
 516:	12 96       	adiw	r26, 0x02	; 2
 518:	9c 93       	st	X, r25
 51a:	12 97       	sbiw	r26, 0x02	; 2

	usart_data->buffer.RX_Tail = 0;
 51c:	1c 96       	adiw	r26, 0x0c	; 12
 51e:	1c 92       	st	X, r1
 520:	1c 97       	sbiw	r26, 0x0c	; 12
	usart_data->buffer.RX_Head = 0;
 522:	1b 96       	adiw	r26, 0x0b	; 11
 524:	1c 92       	st	X, r1
 526:	1b 97       	sbiw	r26, 0x0b	; 11
	usart_data->buffer.TX_Tail = 0;
 528:	1e 96       	adiw	r26, 0x0e	; 14
 52a:	1c 92       	st	X, r1
 52c:	1e 97       	sbiw	r26, 0x0e	; 14
	usart_data->buffer.TX_Head = 0;
 52e:	1d 96       	adiw	r26, 0x0d	; 13
 530:	1c 92       	st	X, r1
	/* Use USARTC0 and initialize buffers. */
	USART_InterruptDriver_Initialize(&USART_data, &USART, USART_DREINTLVL_LO_gc);

	/* USARTC0, 8 Data bits, No Parity, 1 Stop bit. */
	USART_Format_Set(USART_data.usart, USART_CHSIZE_8BIT_gc,
 532:	93 e0       	ldi	r25, 0x03	; 3
 534:	95 83       	std	Z+5, r25	; 0x05
	USART_PMODE_DISABLED_gc, false);

	/* Enable RXC interrupt. */
	USART_RxdInterruptLevel_Set(USART_data.usart, USART_RXCINTLVL_LO_gc);
 536:	93 81       	ldd	r25, Z+3	; 0x03
 538:	9f 7c       	andi	r25, 0xCF	; 207
 53a:	90 61       	ori	r25, 0x10	; 16
 53c:	93 83       	std	Z+3, r25	; 0x03
	USART_Baudrate_Set(&USART, 12 , 0);
 53e:	9c e0       	ldi	r25, 0x0C	; 12
 540:	96 83       	std	Z+6, r25	; 0x06
 542:	17 82       	std	Z+7, r1	; 0x07

	/* Enable both RX and TX. */
	USART_Rx_Enable(USART_data.usart);
 544:	94 81       	ldd	r25, Z+4	; 0x04
 546:	90 61       	ori	r25, 0x10	; 16
 548:	94 83       	std	Z+4, r25	; 0x04
	USART_Tx_Enable(USART_data.usart);
 54a:	94 81       	ldd	r25, Z+4	; 0x04
 54c:	98 60       	ori	r25, 0x08	; 8
 54e:	94 83       	std	Z+4, r25	; 0x04

	/* Enable PMIC interrupt level low. */
	PMIC.CTRL |= PMIC_LOLVLEX_bm;
 550:	e0 ea       	ldi	r30, 0xA0	; 160
 552:	f0 e0       	ldi	r31, 0x00	; 0
 554:	92 81       	ldd	r25, Z+2	; 0x02
 556:	91 60       	ori	r25, 0x01	; 1
 558:	92 83       	std	Z+2, r25	; 0x02

	/* Enable global interrupts. */
	sei();
 55a:	78 94       	sei

	/* Send sendArray. */
	sendArray[0]=data;
 55c:	80 93 80 20 	sts	0x2080, r24	; 0x802080 <sendArray>
	i = 0;
	while (i < 1) {
		bool Tobuffer;
		Tobuffer=	USART_TXBuffer_PutByte(&USART_data, sendArray[i]);
 560:	c0 e8       	ldi	r28, 0x80	; 128
 562:	d0 e2       	ldi	r29, 0x20	; 32
 564:	68 81       	ld	r22, Y
 566:	8d ef       	ldi	r24, 0xFD	; 253
 568:	90 e2       	ldi	r25, 0x20	; 32
 56a:	0e 94 58 01 	call	0x2b0	; 0x2b0 <USART_TXBuffer_PutByte>
	sei();

	/* Send sendArray. */
	sendArray[0]=data;
	i = 0;
	while (i < 1) {
 56e:	88 23       	and	r24, r24
 570:	c9 f3       	breq	.-14     	; 0x564 <transmit_USART+0x6e>
		
		if(Tobuffer){
			i++;
		}
	}
}
 572:	df 91       	pop	r29
 574:	cf 91       	pop	r28
 576:	08 95       	ret

00000578 <transmit_string_USART>:

void transmit_string_USART(char *string)
{
 578:	cf 93       	push	r28
 57a:	bc 01       	movw	r22, r24
	uint8_t i;
	PORTC.DIRSET   = PIN3_bm;
 57c:	e0 e4       	ldi	r30, 0x40	; 64
 57e:	f6 e0       	ldi	r31, 0x06	; 6
 580:	88 e0       	ldi	r24, 0x08	; 8
 582:	81 83       	std	Z+1, r24	; 0x01
	PORTC.DIRCLR   = PIN2_bm;
 584:	84 e0       	ldi	r24, 0x04	; 4
 586:	82 83       	std	Z+2, r24	; 0x02
 */
void USART_InterruptDriver_Initialize(USART_data_t * usart_data,
                                      USART_t * usart,
                                      USART_DREINTLVL_t dreIntLevel)
{
	usart_data->usart = usart;
 588:	ad ef       	ldi	r26, 0xFD	; 253
 58a:	b0 e2       	ldi	r27, 0x20	; 32
 58c:	e0 ea       	ldi	r30, 0xA0	; 160
 58e:	f8 e0       	ldi	r31, 0x08	; 8
 590:	ed 93       	st	X+, r30
 592:	fc 93       	st	X, r31
 594:	11 97       	sbiw	r26, 0x01	; 1
	usart_data->dreIntLevel = dreIntLevel;
 596:	81 e0       	ldi	r24, 0x01	; 1
 598:	12 96       	adiw	r26, 0x02	; 2
 59a:	8c 93       	st	X, r24
 59c:	12 97       	sbiw	r26, 0x02	; 2

	usart_data->buffer.RX_Tail = 0;
 59e:	1c 96       	adiw	r26, 0x0c	; 12
 5a0:	1c 92       	st	X, r1
 5a2:	1c 97       	sbiw	r26, 0x0c	; 12
	usart_data->buffer.RX_Head = 0;
 5a4:	1b 96       	adiw	r26, 0x0b	; 11
 5a6:	1c 92       	st	X, r1
 5a8:	1b 97       	sbiw	r26, 0x0b	; 11
	usart_data->buffer.TX_Tail = 0;
 5aa:	1e 96       	adiw	r26, 0x0e	; 14
 5ac:	1c 92       	st	X, r1
 5ae:	1e 97       	sbiw	r26, 0x0e	; 14
	usart_data->buffer.TX_Head = 0;
 5b0:	1d 96       	adiw	r26, 0x0d	; 13
 5b2:	1c 92       	st	X, r1
	/* Use USARTC0 and initialize buffers. */
	USART_InterruptDriver_Initialize(&USART_data, &USART, USART_DREINTLVL_LO_gc);

	/* USARTC0, 8 Data bits, No Parity, 1 Stop bit. */
	USART_Format_Set(USART_data.usart, USART_CHSIZE_8BIT_gc,
 5b4:	83 e0       	ldi	r24, 0x03	; 3
 5b6:	85 83       	std	Z+5, r24	; 0x05
	USART_PMODE_DISABLED_gc, false);

	/* Enable RXC interrupt. */
	USART_RxdInterruptLevel_Set(USART_data.usart, USART_RXCINTLVL_LO_gc);
 5b8:	93 81       	ldd	r25, Z+3	; 0x03
 5ba:	9f 7c       	andi	r25, 0xCF	; 207
 5bc:	90 61       	ori	r25, 0x10	; 16
 5be:	93 83       	std	Z+3, r25	; 0x03
	USART_Baudrate_Set(&USART, 12 , 0);
 5c0:	8c e0       	ldi	r24, 0x0C	; 12
 5c2:	86 83       	std	Z+6, r24	; 0x06
 5c4:	17 82       	std	Z+7, r1	; 0x07

	/* Enable both RX and TX. */
	USART_Rx_Enable(USART_data.usart);
 5c6:	94 81       	ldd	r25, Z+4	; 0x04
 5c8:	90 61       	ori	r25, 0x10	; 16
 5ca:	94 83       	std	Z+4, r25	; 0x04
	USART_Tx_Enable(USART_data.usart);
 5cc:	94 81       	ldd	r25, Z+4	; 0x04
 5ce:	98 60       	ori	r25, 0x08	; 8
 5d0:	94 83       	std	Z+4, r25	; 0x04

	/* Enable PMIC interrupt level low. */
	PMIC.CTRL |= PMIC_LOLVLEX_bm;
 5d2:	e0 ea       	ldi	r30, 0xA0	; 160
 5d4:	f0 e0       	ldi	r31, 0x00	; 0
 5d6:	92 81       	ldd	r25, Z+2	; 0x02
 5d8:	91 60       	ori	r25, 0x01	; 1
 5da:	92 83       	std	Z+2, r25	; 0x02

	/* Enable global interrupts. */
	sei();
 5dc:	78 94       	sei

	/* Send sendArray. */
	strcpy(sendArray,string);
 5de:	80 e8       	ldi	r24, 0x80	; 128
 5e0:	90 e2       	ldi	r25, 0x20	; 32
 5e2:	0e 94 9d 04 	call	0x93a	; 0x93a <strcpy>
	i = 0;
 5e6:	c0 e0       	ldi	r28, 0x00	; 0
	while (i < 61) {
		bool Tobuffer;
		Tobuffer=	USART_TXBuffer_PutByte(&USART_data, sendArray[i]);
 5e8:	ec 2f       	mov	r30, r28
 5ea:	f0 e0       	ldi	r31, 0x00	; 0
 5ec:	e0 58       	subi	r30, 0x80	; 128
 5ee:	ff 4d       	sbci	r31, 0xDF	; 223
 5f0:	60 81       	ld	r22, Z
 5f2:	8d ef       	ldi	r24, 0xFD	; 253
 5f4:	90 e2       	ldi	r25, 0x20	; 32
 5f6:	0e 94 58 01 	call	0x2b0	; 0x2b0 <USART_TXBuffer_PutByte>
		
		if(Tobuffer){
 5fa:	81 11       	cpse	r24, r1
			i++;
 5fc:	cf 5f       	subi	r28, 0xFF	; 255
	sei();

	/* Send sendArray. */
	strcpy(sendArray,string);
	i = 0;
	while (i < 61) {
 5fe:	cd 33       	cpi	r28, 0x3D	; 61
 600:	98 f3       	brcs	.-26     	; 0x5e8 <transmit_string_USART+0x70>
		
		if(Tobuffer){
			i++;
		}
	}
}
 602:	cf 91       	pop	r28
 604:	08 95       	ret

00000606 <ccxxx0_Setup>:

void ccxxx0_Setup(const RF_SETTINGS* settings)			// - DONE
{
 606:	cf 93       	push	r28
 608:	df 93       	push	r29
 60a:	ec 01       	movw	r28, r24
	unsigned char read;
	// Write register settings
	ccxxx0_Write(CCxxx0_IOCFG0,   settings->IOCFG0);
 60c:	68 81       	ld	r22, Y
 60e:	82 e0       	ldi	r24, 0x02	; 2
 610:	0e 94 c4 01 	call	0x388	; 0x388 <ccxxx0_Write>
	read = ccxxx0_Read(CCxxx0_IOCFG0);
 614:	82 e0       	ldi	r24, 0x02	; 2
 616:	0e 94 a5 01 	call	0x34a	; 0x34a <ccxxx0_Read>
	//transmit_USART(read);
	ccxxx0_Write(CCxxx0_FIFOTHR,  settings->FIFOTHR);
 61a:	69 81       	ldd	r22, Y+1	; 0x01
 61c:	83 e0       	ldi	r24, 0x03	; 3
 61e:	0e 94 c4 01 	call	0x388	; 0x388 <ccxxx0_Write>
	read = ccxxx0_Read(CCxxx0_FIFOTHR);
 622:	83 e0       	ldi	r24, 0x03	; 3
 624:	0e 94 a5 01 	call	0x34a	; 0x34a <ccxxx0_Read>
	//transmit_USART(read);
	ccxxx0_Write(CCxxx0_PKTCTRL0, settings->PKTCTRL0);
 628:	6a 81       	ldd	r22, Y+2	; 0x02
 62a:	88 e0       	ldi	r24, 0x08	; 8
 62c:	0e 94 c4 01 	call	0x388	; 0x388 <ccxxx0_Write>
	read = ccxxx0_Read(CCxxx0_PKTCTRL0);
 630:	88 e0       	ldi	r24, 0x08	; 8
 632:	0e 94 a5 01 	call	0x34a	; 0x34a <ccxxx0_Read>
	//transmit_USART(read);
	ccxxx0_Write(CCxxx0_FSCTRL1,  settings->FSCTRL1);
 636:	6b 81       	ldd	r22, Y+3	; 0x03
 638:	8b e0       	ldi	r24, 0x0B	; 11
 63a:	0e 94 c4 01 	call	0x388	; 0x388 <ccxxx0_Write>
	read = ccxxx0_Read(CCxxx0_FSCTRL1);
 63e:	8b e0       	ldi	r24, 0x0B	; 11
 640:	0e 94 a5 01 	call	0x34a	; 0x34a <ccxxx0_Read>
	//transmit_USART(read);
	//ccxxx0_Write(CCxxx0_FSCTRL0,  settings->FSCTRL0);
	ccxxx0_Write(CCxxx0_FREQ2,    settings->FREQ2);
 644:	6c 81       	ldd	r22, Y+4	; 0x04
 646:	8d e0       	ldi	r24, 0x0D	; 13
 648:	0e 94 c4 01 	call	0x388	; 0x388 <ccxxx0_Write>
	read = ccxxx0_Read(CCxxx0_FREQ2);
 64c:	8d e0       	ldi	r24, 0x0D	; 13
 64e:	0e 94 a5 01 	call	0x34a	; 0x34a <ccxxx0_Read>
	//transmit_USART(read);
	ccxxx0_Write(CCxxx0_FREQ1,    settings->FREQ1);
 652:	6d 81       	ldd	r22, Y+5	; 0x05
 654:	8e e0       	ldi	r24, 0x0E	; 14
 656:	0e 94 c4 01 	call	0x388	; 0x388 <ccxxx0_Write>
	read = ccxxx0_Read(CCxxx0_FREQ1);
 65a:	8e e0       	ldi	r24, 0x0E	; 14
 65c:	0e 94 a5 01 	call	0x34a	; 0x34a <ccxxx0_Read>
	//transmit_USART(read);
	ccxxx0_Write(CCxxx0_FREQ0,    settings->FREQ0);
 660:	6e 81       	ldd	r22, Y+6	; 0x06
 662:	8f e0       	ldi	r24, 0x0F	; 15
 664:	0e 94 c4 01 	call	0x388	; 0x388 <ccxxx0_Write>
	read = ccxxx0_Read(CCxxx0_FREQ0);
 668:	8f e0       	ldi	r24, 0x0F	; 15
 66a:	0e 94 a5 01 	call	0x34a	; 0x34a <ccxxx0_Read>
	//transmit_USART(read);
	ccxxx0_Write(CCxxx0_MDMCFG4,  settings->MDMCFG4);
 66e:	6f 81       	ldd	r22, Y+7	; 0x07
 670:	80 e1       	ldi	r24, 0x10	; 16
 672:	0e 94 c4 01 	call	0x388	; 0x388 <ccxxx0_Write>
	read = ccxxx0_Read(CCxxx0_MDMCFG4);
 676:	80 e1       	ldi	r24, 0x10	; 16
 678:	0e 94 a5 01 	call	0x34a	; 0x34a <ccxxx0_Read>
	//transmit_USART(read);
	ccxxx0_Write(CCxxx0_MDMCFG3,  settings->MDMCFG3);
 67c:	68 85       	ldd	r22, Y+8	; 0x08
 67e:	81 e1       	ldi	r24, 0x11	; 17
 680:	0e 94 c4 01 	call	0x388	; 0x388 <ccxxx0_Write>
	read = ccxxx0_Read(CCxxx0_MDMCFG3);
 684:	81 e1       	ldi	r24, 0x11	; 17
 686:	0e 94 a5 01 	call	0x34a	; 0x34a <ccxxx0_Read>
	//transmit_USART(read);
	ccxxx0_Write(CCxxx0_MDMCFG2,  settings->MDMCFG2);
 68a:	69 85       	ldd	r22, Y+9	; 0x09
 68c:	82 e1       	ldi	r24, 0x12	; 18
 68e:	0e 94 c4 01 	call	0x388	; 0x388 <ccxxx0_Write>
	read = ccxxx0_Read(CCxxx0_MDMCFG2);
 692:	82 e1       	ldi	r24, 0x12	; 18
 694:	0e 94 a5 01 	call	0x34a	; 0x34a <ccxxx0_Read>
	//transmit_USART(read);
	//ccxxx0_Write(CCxxx0_MDMCFG1,  settings->MDMCFG1);
	//ccxxx0_Write(CCxxx0_MDMCFG0,  settings->MDMCFG0);
	ccxxx0_Write(CCxxx0_DEVIATN,  settings->DEVIATN);
 698:	6a 85       	ldd	r22, Y+10	; 0x0a
 69a:	85 e1       	ldi	r24, 0x15	; 21
 69c:	0e 94 c4 01 	call	0x388	; 0x388 <ccxxx0_Write>
	read = ccxxx0_Read(CCxxx0_DEVIATN);
 6a0:	85 e1       	ldi	r24, 0x15	; 21
 6a2:	0e 94 a5 01 	call	0x34a	; 0x34a <ccxxx0_Read>
	//transmit_USART(read);
	ccxxx0_Write(CCxxx0_MCSM0 ,   settings->MCSM0 );
 6a6:	6b 85       	ldd	r22, Y+11	; 0x0b
 6a8:	88 e1       	ldi	r24, 0x18	; 24
 6aa:	0e 94 c4 01 	call	0x388	; 0x388 <ccxxx0_Write>
	read = ccxxx0_Read(CCxxx0_MCSM0);
 6ae:	88 e1       	ldi	r24, 0x18	; 24
 6b0:	0e 94 a5 01 	call	0x34a	; 0x34a <ccxxx0_Read>
	//transmit_USART(read);
	ccxxx0_Write(CCxxx0_FOCCFG,   settings->FOCCFG);
 6b4:	6c 85       	ldd	r22, Y+12	; 0x0c
 6b6:	89 e1       	ldi	r24, 0x19	; 25
 6b8:	0e 94 c4 01 	call	0x388	; 0x388 <ccxxx0_Write>
	read = ccxxx0_Read(CCxxx0_FOCCFG);
 6bc:	89 e1       	ldi	r24, 0x19	; 25
 6be:	0e 94 a5 01 	call	0x34a	; 0x34a <ccxxx0_Read>
	//transmit_USART(read);
	//ccxxx0_Write(CCxxx0_BSCFG,    settings->BSCFG);
	ccxxx0_Write(CCxxx0_WORCTRL,  settings->WORCTRL);
 6c2:	6d 85       	ldd	r22, Y+13	; 0x0d
 6c4:	80 e2       	ldi	r24, 0x20	; 32
 6c6:	0e 94 c4 01 	call	0x388	; 0x388 <ccxxx0_Write>
	read = ccxxx0_Read(CCxxx0_WORCTRL);
 6ca:	80 e2       	ldi	r24, 0x20	; 32
 6cc:	0e 94 a5 01 	call	0x34a	; 0x34a <ccxxx0_Read>
	//transmit_USART(read);
	ccxxx0_Write(CCxxx0_FSCAL3,   settings->FSCAL3);
 6d0:	6e 85       	ldd	r22, Y+14	; 0x0e
 6d2:	83 e2       	ldi	r24, 0x23	; 35
 6d4:	0e 94 c4 01 	call	0x388	; 0x388 <ccxxx0_Write>
	read = ccxxx0_Read(CCxxx0_FSCAL3);
 6d8:	83 e2       	ldi	r24, 0x23	; 35
 6da:	0e 94 a5 01 	call	0x34a	; 0x34a <ccxxx0_Read>
	//transmit_USART(read);
	ccxxx0_Write(CCxxx0_FSCAL2,   settings->FSCAL2);
 6de:	6f 85       	ldd	r22, Y+15	; 0x0f
 6e0:	84 e2       	ldi	r24, 0x24	; 36
 6e2:	0e 94 c4 01 	call	0x388	; 0x388 <ccxxx0_Write>
	read = ccxxx0_Read(CCxxx0_FSCAL2);
 6e6:	84 e2       	ldi	r24, 0x24	; 36
 6e8:	0e 94 a5 01 	call	0x34a	; 0x34a <ccxxx0_Read>
	//transmit_USART(read);
	ccxxx0_Write(CCxxx0_FSCAL1,   settings->FSCAL1);
 6ec:	68 89       	ldd	r22, Y+16	; 0x10
 6ee:	85 e2       	ldi	r24, 0x25	; 37
 6f0:	0e 94 c4 01 	call	0x388	; 0x388 <ccxxx0_Write>
	read = ccxxx0_Read(CCxxx0_FSCAL1);
 6f4:	85 e2       	ldi	r24, 0x25	; 37
 6f6:	0e 94 a5 01 	call	0x34a	; 0x34a <ccxxx0_Read>
	//transmit_USART(read);
	ccxxx0_Write(CCxxx0_FSCAL0,   settings->FSCAL0);
 6fa:	69 89       	ldd	r22, Y+17	; 0x11
 6fc:	86 e2       	ldi	r24, 0x26	; 38
 6fe:	0e 94 c4 01 	call	0x388	; 0x388 <ccxxx0_Write>
	read = ccxxx0_Read(CCxxx0_FSCAL0);
 702:	86 e2       	ldi	r24, 0x26	; 38
 704:	0e 94 a5 01 	call	0x34a	; 0x34a <ccxxx0_Read>
	//transmit_USART(read);
	ccxxx0_Write(CCxxx0_TEST2,    settings->TEST2);
 708:	6a 89       	ldd	r22, Y+18	; 0x12
 70a:	8c e2       	ldi	r24, 0x2C	; 44
 70c:	0e 94 c4 01 	call	0x388	; 0x388 <ccxxx0_Write>
	read = ccxxx0_Read(CCxxx0_TEST2);
 710:	8c e2       	ldi	r24, 0x2C	; 44
 712:	0e 94 a5 01 	call	0x34a	; 0x34a <ccxxx0_Read>
	//transmit_USART(read);
	ccxxx0_Write(CCxxx0_TEST1,    settings->TEST1);
 716:	6b 89       	ldd	r22, Y+19	; 0x13
 718:	8d e2       	ldi	r24, 0x2D	; 45
 71a:	0e 94 c4 01 	call	0x388	; 0x388 <ccxxx0_Write>
	read = ccxxx0_Read(CCxxx0_TEST1);
 71e:	8d e2       	ldi	r24, 0x2D	; 45
 720:	0e 94 a5 01 	call	0x34a	; 0x34a <ccxxx0_Read>
	//transmit_USART(read);
	ccxxx0_Write(CCxxx0_TEST0,    settings->TEST0);
 724:	6c 89       	ldd	r22, Y+20	; 0x14
 726:	8e e2       	ldi	r24, 0x2E	; 46
 728:	0e 94 c4 01 	call	0x388	; 0x388 <ccxxx0_Write>
	read = ccxxx0_Read(CCxxx0_TEST0);
 72c:	8e e2       	ldi	r24, 0x2E	; 46
 72e:	0e 94 a5 01 	call	0x34a	; 0x34a <ccxxx0_Read>
	//transmit_USART(read);
}
 732:	df 91       	pop	r29
 734:	cf 91       	pop	r28
 736:	08 95       	ret

00000738 <CC_Receive>:


void CC_Receive()				// - DONE
{
 738:	cf 93       	push	r28
 73a:	df 93       	push	r29
 73c:	cd b7       	in	r28, 0x3d	; 61
 73e:	de b7       	in	r29, 0x3e	; 62
 740:	ee 97       	sbiw	r28, 0x3e	; 62
 742:	cd bf       	out	0x3d, r28	; 61
 744:	de bf       	out	0x3e, r29	; 62
	transmit_enable = 0;
 746:	10 92 42 20 	sts	0x2042, r1	; 0x802042 <__data_end>
	unsigned char temp[62];
	ccxxx0_Strobe(CCxxx0_SIDLE);//Exit RX / TX, turn off frequency synthesizer and exit Wake-On-Radio mode if applicable
 74a:	86 e3       	ldi	r24, 0x36	; 54
 74c:	0e 94 e2 01 	call	0x3c4	; 0x3c4 <ccxxx0_Strobe>
	ccxxx0_WriteBurst(CCxxx0_PATABLE, &paTable[0], 1); // max power
 750:	41 e0       	ldi	r20, 0x01	; 1
 752:	50 e0       	ldi	r21, 0x00	; 0
 754:	60 e0       	ldi	r22, 0x00	; 0
 756:	70 e2       	ldi	r23, 0x20	; 32
 758:	8e e3       	ldi	r24, 0x3E	; 62
 75a:	0e 94 24 02 	call	0x448	; 0x448 <ccxxx0_WriteBurst>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 75e:	83 ef       	ldi	r24, 0xF3	; 243
 760:	91 e0       	ldi	r25, 0x01	; 1
 762:	01 97       	sbiw	r24, 0x01	; 1
 764:	f1 f7       	brne	.-4      	; 0x762 <CC_Receive+0x2a>
 766:	00 c0       	rjmp	.+0      	; 0x768 <CC_Receive+0x30>
 768:	00 00       	nop
	_delay_ms(1);
	ccxxx0_Strobe(CCxxx0_SFRX); // flush rx buff
 76a:	8a e3       	ldi	r24, 0x3A	; 58
 76c:	0e 94 e2 01 	call	0x3c4	; 0x3c4 <ccxxx0_Strobe>
	ccxxx0_Strobe(CCxxx0_SRX);// goto rx mode
 770:	84 e3       	ldi	r24, 0x34	; 52
 772:	0e 94 e2 01 	call	0x3c4	; 0x3c4 <ccxxx0_Strobe>
	{
		char bytes_RXFIFO = ccxxx0_Read(CCxxx0_RXBYTES);

		//transmit_string_USART("Hello2");

		if(PORTE.IN & (1 << CC_GPIO0))
 776:	00 e8       	ldi	r16, 0x80	; 128
 778:	16 e0       	ldi	r17, 0x06	; 6
 77a:	7e 01       	movw	r14, r28
 77c:	9b e3       	ldi	r25, 0x3B	; 59
 77e:	e9 0e       	add	r14, r25
 780:	f1 1c       	adc	r15, r1
			if ((temp[1] == 'C')&&(temp[2] == 'Q')){ // 'A' in binary is 01000001
				transmit_string_USART("Entered if \n");
			for(int i=0;i<34;i++) {
				data[i] = temp[24+i];
			}
			data[35]='\0';
 782:	0f 2e       	mov	r0, r31
 784:	f3 e6       	ldi	r31, 0x63	; 99
 786:	4f 2e       	mov	r4, r31
 788:	f1 e2       	ldi	r31, 0x21	; 33
 78a:	5f 2e       	mov	r5, r31
 78c:	f0 2d       	mov	r31, r0
			//	transmit_string_USART("Frame Received with no errors\r\n");
				_delay_ms(5);
				//transmit_string_USART("Data = ");
				_delay_ms(5);
				//transmit_string_USART(data);
				data[34] = 'm';
 78e:	0f 2e       	mov	r0, r31
 790:	fd e6       	ldi	r31, 0x6D	; 109
 792:	7f 2e       	mov	r7, r31
 794:	f0 2d       	mov	r31, r0
 796:	0f 2e       	mov	r0, r31
 798:	f6 e8       	ldi	r31, 0x86	; 134
 79a:	af 2e       	mov	r10, r31
 79c:	f1 e2       	ldi	r31, 0x21	; 33
 79e:	bf 2e       	mov	r11, r31
 7a0:	f0 2d       	mov	r31, r0
				for(int i =0; i<35; i++){
					transmit_USART(data[i]);
				}
				_delay_ms(5);
				transmit_USART("\n");
 7a2:	0f 2e       	mov	r0, r31
 7a4:	f0 e4       	ldi	r31, 0x40	; 64
 7a6:	8f 2e       	mov	r8, r31
 7a8:	f0 e2       	ldi	r31, 0x20	; 32
 7aa:	9f 2e       	mov	r9, r31
 7ac:	f0 2d       	mov	r31, r0
	ccxxx0_Strobe(CCxxx0_SFRX); // flush rx buff
	ccxxx0_Strobe(CCxxx0_SRX);// goto rx mode

	while(1)
	{
		char bytes_RXFIFO = ccxxx0_Read(CCxxx0_RXBYTES);
 7ae:	8b ef       	ldi	r24, 0xFB	; 251
 7b0:	0e 94 a5 01 	call	0x34a	; 0x34a <ccxxx0_Read>

		//transmit_string_USART("Hello2");

		if(PORTE.IN & (1 << CC_GPIO0))
 7b4:	f8 01       	movw	r30, r16
 7b6:	80 85       	ldd	r24, Z+8	; 0x08
 7b8:	80 ff       	sbrs	r24, 0
 7ba:	f9 cf       	rjmp	.-14     	; 0x7ae <CC_Receive+0x76>
		{
			//transmit_string_USART("package available \n");
			//transmit_string_USART("Hello1");
			while(PORTE.IN & (1 << CC_GPIO0)){
 7bc:	f8 01       	movw	r30, r16
 7be:	80 85       	ldd	r24, Z+8	; 0x08
 7c0:	80 fd       	sbrc	r24, 0
 7c2:	fc cf       	rjmp	.-8      	; 0x7bc <CC_Receive+0x84>
				//transmit_string_USART("in");
			}
			//char bytes_RXFIFO = ccxxx0_Read(CCxxx0_RXBYTES);
			//transmit_string_USART("Hello");
			char bytes_RXFIFO = ccxxx0_Read(CCxxx0_RXBYTES);
 7c4:	8b ef       	ldi	r24, 0xFB	; 251
 7c6:	0e 94 a5 01 	call	0x34a	; 0x34a <ccxxx0_Read>
			}*/


			//for(int i =0; i<35; i++){
			//temp[i] = ccxxx0_Read(CCxxx0_RXFIFO);}
			ccxxx0_ReadBurst(CCxxx0_RXFIFO, temp,61);
 7ca:	4d e3       	ldi	r20, 0x3D	; 61
 7cc:	50 e0       	ldi	r21, 0x00	; 0
 7ce:	be 01       	movw	r22, r28
 7d0:	6f 5f       	subi	r22, 0xFF	; 255
 7d2:	7f 4f       	sbci	r23, 0xFF	; 255
 7d4:	8f e3       	ldi	r24, 0x3F	; 63
 7d6:	0e 94 f7 01 	call	0x3ee	; 0x3ee <ccxxx0_ReadBurst>
			//transmit_string_USART("RXed data: ");
			ccxxx0_Strobe(CCxxx0_SFRX); // flush rx buf
 7da:	8a e3       	ldi	r24, 0x3A	; 58
 7dc:	0e 94 e2 01 	call	0x3c4	; 0x3c4 <ccxxx0_Strobe>
			ccxxx0_Strobe(CCxxx0_SRX); // goto rx mode
 7e0:	84 e3       	ldi	r24, 0x34	; 52
 7e2:	0e 94 e2 01 	call	0x3c4	; 0x3c4 <ccxxx0_Strobe>
			/*for(int i = 0; i< 39; i++){
				transmit_USART(temp[i]);
			}
			*/
			//transmit_string_USART("About to Enter \n");
			if ((temp[1] == 'C')&&(temp[2] == 'Q')){ // 'A' in binary is 01000001
 7e6:	8a 81       	ldd	r24, Y+2	; 0x02
 7e8:	83 34       	cpi	r24, 0x43	; 67
 7ea:	09 f0       	breq	.+2      	; 0x7ee <CC_Receive+0xb6>
 7ec:	6a c0       	rjmp	.+212    	; 0x8c2 <CC_Receive+0x18a>
 7ee:	8b 81       	ldd	r24, Y+3	; 0x03
 7f0:	81 35       	cpi	r24, 0x51	; 81
 7f2:	09 f0       	breq	.+2      	; 0x7f6 <CC_Receive+0xbe>
 7f4:	66 c0       	rjmp	.+204    	; 0x8c2 <CC_Receive+0x18a>
				transmit_string_USART("Entered if \n");
 7f6:	8b e2       	ldi	r24, 0x2B	; 43
 7f8:	90 e2       	ldi	r25, 0x20	; 32
 7fa:	0e 94 bc 02 	call	0x578	; 0x578 <transmit_string_USART>
 7fe:	fe 01       	movw	r30, r28
 800:	79 96       	adiw	r30, 0x19	; 25
 802:	0f 2e       	mov	r0, r31
 804:	f3 e6       	ldi	r31, 0x63	; 99
 806:	cf 2e       	mov	r12, r31
 808:	f1 e2       	ldi	r31, 0x21	; 33
 80a:	df 2e       	mov	r13, r31
 80c:	f0 2d       	mov	r31, r0
 80e:	d6 01       	movw	r26, r12
			for(int i=0;i<34;i++) {
				data[i] = temp[24+i];
 810:	81 91       	ld	r24, Z+
 812:	8d 93       	st	X+, r24
			}
			*/
			//transmit_string_USART("About to Enter \n");
			if ((temp[1] == 'C')&&(temp[2] == 'Q')){ // 'A' in binary is 01000001
				transmit_string_USART("Entered if \n");
			for(int i=0;i<34;i++) {
 814:	ee 15       	cp	r30, r14
 816:	ff 05       	cpc	r31, r15
 818:	d9 f7       	brne	.-10     	; 0x810 <CC_Receive+0xd8>
				data[i] = temp[24+i];
			}
			data[35]='\0';
 81a:	f2 01       	movw	r30, r4
 81c:	13 a2       	std	Z+35, r1	; 0x23

			uint8_t *framePtr;
			framePtr = temp;
			crc = crc16(temp+1,57);
 81e:	69 e3       	ldi	r22, 0x39	; 57
 820:	ce 01       	movw	r24, r28
 822:	02 96       	adiw	r24, 0x02	; 2
 824:	0e 94 21 01 	call	0x242	; 0x242 <crc16>
 828:	80 93 fb 20 	sts	0x20FB, r24	; 0x8020fb <crc>
 82c:	90 93 fc 20 	sts	0x20FC, r25	; 0x8020fc <crc+0x1>
 830:	83 ec       	ldi	r24, 0xC3	; 195
 832:	99 e0       	ldi	r25, 0x09	; 9
 834:	01 97       	sbiw	r24, 0x01	; 1
 836:	f1 f7       	brne	.-4      	; 0x834 <CC_Receive+0xfc>
 838:	00 c0       	rjmp	.+0      	; 0x83a <CC_Receive+0x102>
 83a:	00 00       	nop
			//transmit_string_USART("CRC Computed=\r\n");
			_delay_ms(5);
			crc1 = crc;
 83c:	90 91 fb 20 	lds	r25, 0x20FB	; 0x8020fb <crc>
 840:	80 91 fc 20 	lds	r24, 0x20FC	; 0x8020fc <crc+0x1>
 844:	90 93 fa 20 	sts	0x20FA, r25	; 0x8020fa <crc1>
			crc2 = (crc>>8);
 848:	80 93 ae 21 	sts	0x21AE, r24	; 0x8021ae <crc2>
 84c:	e7 e8       	ldi	r30, 0x87	; 135
 84e:	f3 e1       	ldi	r31, 0x13	; 19
 850:	31 97       	sbiw	r30, 0x01	; 1
 852:	f1 f7       	brne	.-4      	; 0x850 <CC_Receive+0x118>
 854:	00 c0       	rjmp	.+0      	; 0x856 <CC_Receive+0x11e>
 856:	00 00       	nop
 858:	83 ec       	ldi	r24, 0xC3	; 195
 85a:	99 e0       	ldi	r25, 0x09	; 9
 85c:	01 97       	sbiw	r24, 0x01	; 1
 85e:	f1 f7       	brne	.-4      	; 0x85c <CC_Receive+0x124>
 860:	00 c0       	rjmp	.+0      	; 0x862 <CC_Receive+0x12a>
 862:	00 00       	nop
 864:	e7 e8       	ldi	r30, 0x87	; 135
 866:	f3 e1       	ldi	r31, 0x13	; 19
 868:	31 97       	sbiw	r30, 0x01	; 1
 86a:	f1 f7       	brne	.-4      	; 0x868 <CC_Receive+0x130>
 86c:	00 c0       	rjmp	.+0      	; 0x86e <CC_Receive+0x136>
 86e:	00 00       	nop
			//transmit_USART(temp[59]);
			_delay_ms(10);
			//transmit_string_UART("Now checking equality of the CRCs\r\n");
			//_delay_ms(5);
			//Check if CRCs match
			if((crc1==temp[58])&&(crc2==temp[59])){
 870:	9b ad       	ldd	r25, Y+59	; 0x3b
 872:	80 91 fa 20 	lds	r24, 0x20FA	; 0x8020fa <crc1>
 876:	98 13       	cpse	r25, r24
 878:	24 c0       	rjmp	.+72     	; 0x8c2 <CC_Receive+0x18a>
 87a:	9c ad       	ldd	r25, Y+60	; 0x3c
 87c:	80 91 ae 21 	lds	r24, 0x21AE	; 0x8021ae <crc2>
 880:	98 13       	cpse	r25, r24
 882:	1f c0       	rjmp	.+62     	; 0x8c2 <CC_Receive+0x18a>
 884:	83 ec       	ldi	r24, 0xC3	; 195
 886:	99 e0       	ldi	r25, 0x09	; 9
 888:	01 97       	sbiw	r24, 0x01	; 1
 88a:	f1 f7       	brne	.-4      	; 0x888 <CC_Receive+0x150>
 88c:	00 c0       	rjmp	.+0      	; 0x88e <CC_Receive+0x156>
 88e:	00 00       	nop
 890:	e3 ec       	ldi	r30, 0xC3	; 195
 892:	f9 e0       	ldi	r31, 0x09	; 9
 894:	31 97       	sbiw	r30, 0x01	; 1
 896:	f1 f7       	brne	.-4      	; 0x894 <CC_Receive+0x15c>
 898:	00 c0       	rjmp	.+0      	; 0x89a <CC_Receive+0x162>
 89a:	00 00       	nop
			//	transmit_string_USART("Frame Received with no errors\r\n");
				_delay_ms(5);
				//transmit_string_USART("Data = ");
				_delay_ms(5);
				//transmit_string_USART(data);
				data[34] = 'm';
 89c:	f2 01       	movw	r30, r4
 89e:	72 a2       	std	Z+34, r7	; 0x22
				for(int i =0; i<35; i++){
					transmit_USART(data[i]);
 8a0:	f6 01       	movw	r30, r12
 8a2:	81 91       	ld	r24, Z+
 8a4:	6f 01       	movw	r12, r30
 8a6:	0e 94 7b 02 	call	0x4f6	; 0x4f6 <transmit_USART>
				_delay_ms(5);
				//transmit_string_USART("Data = ");
				_delay_ms(5);
				//transmit_string_USART(data);
				data[34] = 'm';
				for(int i =0; i<35; i++){
 8aa:	ca 14       	cp	r12, r10
 8ac:	db 04       	cpc	r13, r11
 8ae:	c1 f7       	brne	.-16     	; 0x8a0 <CC_Receive+0x168>
 8b0:	83 ec       	ldi	r24, 0xC3	; 195
 8b2:	99 e0       	ldi	r25, 0x09	; 9
 8b4:	01 97       	sbiw	r24, 0x01	; 1
 8b6:	f1 f7       	brne	.-4      	; 0x8b4 <CC_Receive+0x17c>
 8b8:	00 c0       	rjmp	.+0      	; 0x8ba <CC_Receive+0x182>
 8ba:	00 00       	nop
					transmit_USART(data[i]);
				}
				_delay_ms(5);
				transmit_USART("\n");
 8bc:	88 2d       	mov	r24, r8
 8be:	0e 94 7b 02 	call	0x4f6	; 0x4f6 <transmit_USART>
					transmit_string_USART("\r\n");
					//ccxxx0_ReadBurst(CCxxx0_RXFIFO, temp, pkt_length-8);
					//transmit_string_USART((char *)temp);
				}
			}*/
			ccxxx0_Strobe(CCxxx0_SIDLE);//Exit RX / TX, turn off frequency synthesizer and exit Wake-On-Radio mode if applicable
 8c2:	86 e3       	ldi	r24, 0x36	; 54
 8c4:	0e 94 e2 01 	call	0x3c4	; 0x3c4 <ccxxx0_Strobe>
			ccxxx0_WriteBurst(CCxxx0_PATABLE, &paTable[0], 1); // max power
 8c8:	41 e0       	ldi	r20, 0x01	; 1
 8ca:	50 e0       	ldi	r21, 0x00	; 0
 8cc:	60 e0       	ldi	r22, 0x00	; 0
 8ce:	70 e2       	ldi	r23, 0x20	; 32
 8d0:	8e e3       	ldi	r24, 0x3E	; 62
 8d2:	0e 94 24 02 	call	0x448	; 0x448 <ccxxx0_WriteBurst>
 8d6:	e3 ef       	ldi	r30, 0xF3	; 243
 8d8:	f1 e0       	ldi	r31, 0x01	; 1
 8da:	31 97       	sbiw	r30, 0x01	; 1
 8dc:	f1 f7       	brne	.-4      	; 0x8da <CC_Receive+0x1a2>
 8de:	00 c0       	rjmp	.+0      	; 0x8e0 <CC_Receive+0x1a8>
 8e0:	00 00       	nop
			_delay_ms(1);
			ccxxx0_Strobe(CCxxx0_SFRX); // flush rx buf
 8e2:	8a e3       	ldi	r24, 0x3A	; 58
 8e4:	0e 94 e2 01 	call	0x3c4	; 0x3c4 <ccxxx0_Strobe>
			ccxxx0_Strobe(CCxxx0_SRX); // goto rx mode
 8e8:	84 e3       	ldi	r24, 0x34	; 52
 8ea:	0e 94 e2 01 	call	0x3c4	; 0x3c4 <ccxxx0_Strobe>
 8ee:	5f cf       	rjmp	.-322    	; 0x7ae <CC_Receive+0x76>

000008f0 <main>:

	/*uint8_t rssi_dec;
	int16_t rssi_dBm;
	uint8_t rssi_offset = 74; // CC1101 at 433 MHz*/

	cli(); 							//Clears the global interrupts
 8f0:	f8 94       	cli
	SPI_Master_Init();
 8f2:	0e 94 74 01 	call	0x2e8	; 0x2e8 <SPI_Master_Init>
	sei();
 8f6:	78 94       	sei
 8f8:	2f ef       	ldi	r18, 0xFF	; 255
 8fa:	84 e3       	ldi	r24, 0x34	; 52
 8fc:	9c e0       	ldi	r25, 0x0C	; 12
 8fe:	21 50       	subi	r18, 0x01	; 1
 900:	80 40       	sbci	r24, 0x00	; 0
 902:	90 40       	sbci	r25, 0x00	; 0
 904:	e1 f7       	brne	.-8      	; 0x8fe <main+0xe>
 906:	00 c0       	rjmp	.+0      	; 0x908 <main+0x18>
 908:	00 00       	nop

	//transmit_string_USART((unsigned char *)"cc1101_PowerOnReset\r\n");
	_delay_ms(2000);
	ccxxx0_PowerOnReset();
 90a:	0e 94 50 02 	call	0x4a0	; 0x4a0 <ccxxx0_PowerOnReset>
	//PORTC=0x01;
//	_delay_ms(1000);
	//transmit_string_USART((unsigned char *)"cc1101_Setup\r\n");
	ccxxx0_Setup(&rfSettings);
 90e:	81 e0       	ldi	r24, 0x01	; 1
 910:	90 e2       	ldi	r25, 0x20	; 32
 912:	0e 94 03 03 	call	0x606	; 0x606 <ccxxx0_Setup>
	//transmit_string_USART((unsigned char *)"Started\r\n");
	unsigned char part = 'b';
	part = ccxxx0_Read(CCxxx0_VERSION);
 916:	81 ef       	ldi	r24, 0xF1	; 241
 918:	0e 94 a5 01 	call	0x34a	; 0x34a <ccxxx0_Read>
 91c:	2f ef       	ldi	r18, 0xFF	; 255
 91e:	88 e0       	ldi	r24, 0x08	; 8
 920:	9d e3       	ldi	r25, 0x3D	; 61
 922:	21 50       	subi	r18, 0x01	; 1
 924:	80 40       	sbci	r24, 0x00	; 0
 926:	90 40       	sbci	r25, 0x00	; 0
 928:	e1 f7       	brne	.-8      	; 0x922 <main+0x32>
 92a:	00 c0       	rjmp	.+0      	; 0x92c <main+0x3c>
 92c:	00 00       	nop
		//ccxxx0_Write(CCxxx0_IOCFG0, 0x2F);
	for (int i=0;i<5;i++)
		current_status[i]=address[i];
		//transmit_string_USART(address);
		_delay_ms(10000);
		transmit_string_USART("Started \n");
 92e:	88 e3       	ldi	r24, 0x38	; 56
 930:	90 e2       	ldi	r25, 0x20	; 32
 932:	0e 94 bc 02 	call	0x578	; 0x578 <transmit_string_USART>

		while(1)
		{
			//toggle_ind=PINC;
			CC_Receive();
 936:	0e 94 9c 03 	call	0x738	; 0x738 <CC_Receive>

0000093a <strcpy>:
 93a:	fb 01       	movw	r30, r22
 93c:	dc 01       	movw	r26, r24
 93e:	01 90       	ld	r0, Z+
 940:	0d 92       	st	X+, r0
 942:	00 20       	and	r0, r0
 944:	e1 f7       	brne	.-8      	; 0x93e <strcpy+0x4>
 946:	08 95       	ret

00000948 <_exit>:
 948:	f8 94       	cli

0000094a <__stop_program>:
 94a:	ff cf       	rjmp	.-2      	; 0x94a <__stop_program>
